== Serialization: Working with XML and JSON

CodeRAD entities' loose coupling presents advantages beyond the user interface.  Just as you can loosely bind the properties of an entity to a UI View, you can also bind them to elements of and XML or JSON document.  The `ResultParser` class provides a clean and succinct syntax for parsing XML and JSON into entity graphs.

In addition to the ResultParser, CodeRAD provides some convenient utility classes for parsing and querying JSON and XML documents.  This chapter will introduce you to some of these utilities, and provide concrete examples of how they can be used to load data from a JSON or XML web service.

=== Useful Classes

Some of the more useful classes related to XML and JSON parsing are as:

`com.codename1.rad.processing.Result`::
A derivation of the core Codename One https://www.codenameone.com/javadoc/com/codename1/processing/Result.html[Result] class, which provides an expression language similar to https://en.wikipedia.org/wiki/XPath[XPath] for querying XML and JSON documents.  The CodeRAD version of this class fixes a number of bugs, and expands the expression capability with support for additional expressions.  The decision was made to "fork" the Codename One class, rather than fix bugs because legacy applications may be relying on those "bugs", so changing its behaviour would have been too risky.

`com.codename1.rad.io.ElementSelector`::
A utility for querying XML documents using syntax similar to CSS selectors.  This class works similarly to the https://www.codenameone.com/javadoc/com/codename1/ui/ComponentSelector.html[ComponentSelector] class, except that this is optimized to work with XML elements rather than Codename One components.

`com.codename1.rad.io.ResultParser`::
A class that is able to parse XML and JSON documents into entity graphs.  This uses the `Result` class' expression language (similar to XPath syntax) for mapping properties of XML tags and JSON data structures, onto Entity properties.

=== Starting at the end... XML to Entity

Before wading through the details XML, JSON, expression languages, and CSS selectors, let's take a peek at our end goal, which is to convert XML or JSON data into Entities.


Consider the following sample XML file:

.Some sample XML data that we will be parsing into entities using `ResultParser`.
[source,xml]
----
<?xml version="1.0"?>
<catalog>
   <book id="bk101">
      <author>Gambardella, Matthew</author>
      <title>XML Developer's Guide</title>
      <genre>Computer</genre>
      <price>44.95</price>
      <publish_date>2000-10-01</publish_date>
      <description>An in-depth look at creating applications 
      with XML.</description>
   </book>
   <book id="bk102">
      <author>Ralls, Kim</author>
      <title>Midnight Rain</title>
      <genre>Fantasy</genre>
      <price>5.95</price>
      <publish_date>2000-12-16</publish_date>
      <description>A former architect battles corporate zombies, 
      an evil sorceress, and her own childhood to become queen 
      of the world.</description>
   </book>
   <book id="bk103">
      <author>Corets, Eva</author>
      <title>Maeve Ascendant</title>
      <genre>Fantasy</genre>
      <price>5.95</price>
      <publish_date>2000-11-17</publish_date>
      <description>After the collapse of a nanotechnology 
      society in England, the young survivors lay the 
      foundation for a new society.</description>
   </book>
   <book id="bk104">
      <author>Corets, Eva</author>
      <title>Oberon's Legacy</title>
      <genre>Fantasy</genre>
      <price>5.95</price>
      <publish_date>2001-03-10</publish_date>
      <description>In post-apocalypse England, the mysterious 
      agent known only as Oberon helps to create a new life 
      for the inhabitants of London. Sequel to Maeve 
      Ascendant.</description>
   </book>
   <book id="bk105">
      <author>Corets, Eva</author>
      <title>The Sundered Grail</title>
      <genre>Fantasy</genre>
      <price>5.95</price>
      <publish_date>2001-09-10</publish_date>
      <description>The two daughters of Maeve, half-sisters, 
      battle one another for control of England. Sequel to 
      Oberon's Legacy.</description>
   </book>
   <book id="bk106">
      <author>Randall, Cynthia</author>
      <title>Lover Birds</title>
      <genre>Romance</genre>
      <price>4.95</price>
      <publish_date>2000-09-02</publish_date>
      <description>When Carla meets Paul at an ornithology 
      conference, tempers fly as feathers get ruffled.</description>
   </book>
   <book id="bk107">
      <author>Thurman, Paula</author>
      <title>Splish Splash</title>
      <genre>Romance</genre>
      <price>4.95</price>
      <publish_date>2000-11-02</publish_date>
      <description>A deep sea diver finds true love twenty 
      thousand leagues beneath the sea.</description>
   </book>
   <book id="bk108">
      <author>Knorr, Stefan</author>
      <title>Creepy Crawlies</title>
      <genre>Horror</genre>
      <price>4.95</price>
      <publish_date>2000-12-06</publish_date>
      <description>An anthology of horror stories about roaches,
      centipedes, scorpions  and other insects.</description>
   </book>
   <book id="bk109">
      <author>Kress, Peter</author>
      <title>Paradox Lost</title>
      <genre>Science Fiction</genre>
      <price>6.95</price>
      <publish_date>2000-11-02</publish_date>
      <description>After an inadvertant trip through a Heisenberg
      Uncertainty Device, James Salway discovers the problems 
      of being quantum.</description>
   </book>
   <book id="bk110">
      <author>O'Brien, Tim</author>
      <title>Microsoft .NET: The Programming Bible</title>
      <genre>Computer</genre>
      <price>36.95</price>
      <publish_date>2000-12-09</publish_date>
      <description>Microsoft's .NET initiative is explored in 
      detail in this deep programmer's reference.</description>
   </book>
   <book id="bk111">
      <author>O'Brien, Tim</author>
      <title>MSXML3: A Comprehensive Guide</title>
      <genre>Computer</genre>
      <price>36.95</price>
      <publish_date>2000-12-01</publish_date>
      <description>The Microsoft MSXML3 parser is covered in 
      detail, with attention to XML DOM interfaces, XSLT processing, 
      SAX and more.</description>
   </book>
   <book id="bk112">
      <author>Galos, Mike</author>
      <title>Visual Studio 7: A Comprehensive Guide</title>
      <genre>Computer</genre>
      <price>49.95</price>
      <publish_date>2001-04-16</publish_date>
      <description>Microsoft Visual Studio 7 is explored in depth,
      looking at how Visual Basic, Visual C++, C#, and ASP+ are 
      integrated into a comprehensive development 
      environment.</description>
   </book>
</catalog>
----

And suppose our application includes the following entities:

.Minimal source code for a `Book` entity.
[source,java]
----
public class Book extends Entity {
    public static final EntityType TYPE = new EntityTypeBuilder()
        .string(Thing.identifier)
        .string(Thing.name)
        .string(Thing.description)
        .build();
    {
        setEntityType(TYPE);
    }
}
----

.Minimal source code for a `Books` entity. I find it helps for API clarity to create subclasses entity-specific collection types rather than just using generic EntityLists.  This makes it easier for things like the `ResultParser` to introspect the data model and produce better results.
[source,java]
----
public class Books extends EntityList<Book> {}
----

.Minimal source code for a `Catalog` entity.
[source,java]
----
public class Catalog extends Entity {
    public static final Tag BOOKS = new Tag("Books");
    public static final EntityType TYPE = new EntityTypeBuilder()
        .list(Books.class, BOOKS)
        .build();
    {
        setEntityType(TYPE);
    }

}
----

We can convert this XML document into our entities using:

.Using `ResultParser` to parse an XML document into Entities and EntityTypes.
[source,java]
----

ResultParser parser = new ResultParser(Catalog.TYPE) <1>
    .property("./book", Catalog.BOOKS) <2>
    .entity(Book.TYPE) <3>
    .property("@id", Thing.identifier) <4>
    .property("title", Thing.name) <5>
    .property("description", Thing.description); <6>

Catalog catalog = (Catalog)parser.parseXML(xmlContent); <7>
for (Book book : (Books)catalog.get(Catalog.BOOKS)) {
    System.out.println("Name: " + book.get(Thing.name));
}

----
<1> Constructor takes the `Catalog.TYPE` entity type, which is the assigned entity type for the `Catalog` class, thus ensuring that this result parser will map the "root" tag of an XML document to a `Catalog` entity.
<2> "./book" is an expression language selector matching `<book>` elements that are direct children of the "current" element.  `Catalog.BOOKS` indicates that the `<book>` elements should be mapped to the `Catalog.BOOKS` property of the `Catalog` entity.
<3> `entity(Book.TYPE)`, create a new `ResultParser` for mapping the `Book` entity.   This `entity()` method creates the "sub" parser, registers it with the "root" Catalog parser, and returns itself so that subsequent chained method calls are actually performed on the "Book" parser.
<4> Map the "id" attribute of the `<book>` tag to the `Thing.identifier` property of the `Book` entity.
<5> Map the contents of the `<title>` child tag to the `Thing.name` property of the `Book` entity.
<6> Map the contents of the `<description>` child tag to the `Thing.description` property of the `Book` entity.
<7> `parser.parseXML(xmlContent)` parses the provided XML content as a `Catalog` object.


This short example demonstrates how easy it is to parse arbitrary XML into Java entities without dictating any structural requirements on the XML data.  The `ResultParser` uses the Result expression language to specify how the XML data should be mapped to entities. This example, being chosen for clarity and small code-size primarily maps to entities that have the same structure as the XML data, but API is flexible enough to map different structures together.  It also includes advanced facilities for custom content parsing and formatting.  For example, you can provide a `DateFormatter` object to help format dates and time data.


=== JSON to Entity

Lest you think that the ResultParser is geared to XML data input exclusively, here is a motivating example the demonstrates the parsing of JSON data into entities.

[source,json]
----
{
  "colors": [
    {
      "color": "black",
      "category": "hue",
      "type": "primary",
      "code": {
        "rgba": [255,255,255,1],
        "hex": "#000"
      }
    },
    {
      "color": "white",
      "category": "value",
      "code": {
        "rgba": [0,0,0,1],
        "hex": "#FFF"
      }
    },
    {
      "color": "red",
      "category": "hue",
      "type": "primary",
      "code": {
        "rgba": [255,0,0,1],
        "hex": "#FF0"
      }
    },
    {
      "color": "blue",
      "category": "hue",
      "type": "primary",
      "code": {
        "rgba": [0,0,255,1],
        "hex": "#00F"
      }
    },
    {
      "color": "yellow",
      "category": "hue",
      "type": "primary",
      "code": {
        "rgba": [255,255,0,1],
        "hex": "#FF0"
      }
    },
    {
      "color": "green",
      "category": "hue",
      "type": "secondary",
      "code": {
        "rgba": [0,255,0,1],
        "hex": "#0F0"
      }
    },
  ]
}
----



[source,java]
----
class Color extends Entity {
    public static final TYPE = entityTypeBuilder(Color.class)
        .string(Thing.name)
        .string

