== App Example 1: A Twitter Clone

In <<getting-started>> we covered the basics of CodeRAD.  In this chapter we'll put our knowledge to the test as we build a clone of the Twitter mobile app.

As Julie Andrews says, let's start at the very beginning: The start page and signup/signing workflow.  Below are some screenshots from the actual Twitter iOS app running on my iPhone 8.

NOTE: In this chapter we will replicate these forms and workflow using CodeRAD.  This tutorial will focus only on the _client_ portion of the app.  Where the _real_ app would require server interaction (e.g. login and registration), we will create mock implementations that run on the client.  These mock implementations can be extended to support your preferred server-side technology, but that is beyond the scope of this tutorial.

image::images/twitter-entrance-flowchart.png[]

=== Creating the Project

To get started, download the CodeRAD starter project from https://github.com/shannah/coderad2-starter-template/archive/refs/heads/master.zip[here].

Extract the .zip file and then open the project in IntelliJ IDEA

TIP: This is the same starter project that we used in the <<getting-started>> tutorial. I recommend you go through the <<getting-started>> tutorial before starting this one as it will provide you with the fundamentals required to move forward.

The starter project comes preconfigured with placeholders for the maven `groupId` and `artifactId` properties.

Before we begin, let's change the `groupId` and `archetypeId` to better reflect our application.  We'll do this by _cloning_ the project using the `cn1:clone` maven goal.

First expand the _Maven_ side panel (if it isn't already expanded) by clicking on the "Maven" tab on the right side of the IntelliJ window.

image::images/intellij-maven-tab.png[]

Then expand the _myapp_ > _Run Configuration_ node, and double click the _Clone Project_ option.

image::images/intellij-clone-project.png[]

In the dialog prompt, enter the new _groupId_ and _artifactId_ for the project, and select a destination for the new project.  My settings are shown in the screenshot below:

image::images/clone-as-tweet-app-dialog.png[]

After you press _OK_ it will create a new project for you at the location you provided.  In my case, the project will be found at `$HOME/Downloads/tweetapp`.

Clone the current project, and then open the _cloned_ project in IntelliJ.

We are now ready to proceed.





=== Creating the Views

The flow-chart above shows five forms that we will be recreating:

. Welcome Page
. Signup Page
. Signin Page
. Forgot Password
. About Twitter

We'll begin by making empty views for each of these forms.

TIP: All of the views for this project are located in the _common/src/main/rad/views_ directory.  See <<under-the-hood>> for a brief of the project layout.

First let's create a new package for our views.  Expand the _common/src/main/rad/views/com/example/tweetapp_ nodes in the project inspector on the left.  Then right-click the _tweetapp_ node and select _New_ > _Directory_

image::images/tweet-app-new-directory.png[]

Enter "views" for the folder name, and press _Enter_.

image::images/tweet-app-package-name-views.png[]

Then right-click on this new _views_ directory node, and select _New_ > _File_:

image::images/tweet-app-views-new-file.png[]

Enter "WelcomePage.xml", in the prompt, and press _Enter_.

image::images/tweetapp-create-welcomepage.png[]

Now, open the _WelcomePage.xml_ file, and change the contents to the following:

[source,xml]
----
<?xml version="1.0"?>
<y>
    <label>Welcome Page</label>
</y>
----

Before proceeding, let's try running the project in the simulator to make sure that it compiles OK.  Running the project will also run the CodeRAD annotation processor which will generate Java classes from our WelcomePage view so that they will be available for type hinting and auto-complete in IntelliJ.

Press the image:images/intellij-run-button.png[] button on the toolbar.  It may take a while to run the first time as it might have to download dependencies.   Subsequent runs should only take a few seconds.

If all goes well, you should see the simulator pop up with a "Hi World" app as shown here:

image::images/tweetapp-hi-world.png[]

Notice that this isn't showing our _WelcomePage_ yet.  It is showing the default _StartPage_ template from the template.

Let's modify the _ApplicationController_ so that it shows our _WelcomePage_ view as the default view.

The _ApplicationController_ class for this application is defined in the _TweetApp_ class inside the _com.example.tweetapp_ package (inside the _src/main/java_ directory).

image::images/tweetapp-project-inspector-tweetapp-selected.png[]

Open this file and find the `actionPerformed()` method.  It should look something like the following listing:

[source,java]
----
 public void actionPerformed(ControllerEvent evt) {

        with(evt, StartEvent.class, startEvent -> {
           startEvent.setShowingForm(true);
            new StartPageController(this).show();
        });
        super.actionPerformed(evt);
    }
----

TIP: The `actionPerformed()` method is triggered for every event that propagages up to the _ApplicationController_.  You can monitor and handle many application events from inside this method.

Let's change the `new StartPageController(this).show()` call to

[source,java]
----
new WelcomePageController(this).show();
----

NOTE: The `WelcomePageController` class is a `FormController` subclass that is generated from the `WelcomePage.xml` view by the CodeRAD annotation processor.  If you haven't built the project since creating the `WelcomePage.xml` file, then IntelliJ might complain that it can't find the class.  Don't worry, about these warnings as they should "fix" themselves when you run or build the project.

Now, if you restart the simulator, it should show our _WelcomePage_ view.

image::images/tweetapp-welcome-page-form-blank.png[]

=== Hot Reload

The Codename One simulator has a _Hot Reload_ feature that can dramatically improve your development experience by reducing the turnaround time for testing changes to your source code.  See <<hot-reload>> for more information about this feature.

For most of this tutorial, I will be using the _Reload Current Form_ setting of Hot reload so that the simulator will automatically reload the current form after I make changes to the source.

image::images/hot-reload-reload-current-form.png[]


=== The Welcome Page

Our welcome page is currently just a placeholder that says "Welcome".  Let's change it to resemble the Twitter welcome page as shown below:

image::images/twitter-welcome-page.png[]

In order to replicate this content and structure, add the following to the _WelcomePage.xml_ file:

[source,xml]
----
<?xml version="1.0"?>
<borderAbsolute
        xsi:noNamespaceSchemaLocation="WelcomePage.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <y layout-constraint="center">
        <spanLabel>See what's happening in the world right now.</spanLabel>
        <button>Create account</button>
    </y>

    <flow layout-constraint="south">
        <label>Haven an account already?</label>
        <button>Log in</button>
    </flow>
</borderAbsolute>
----

Nothing fancy here.  I'm just trying to _roughly_ replicate how the form is laid out using Codename One's layout managers.   Now reload the simulator (if you have _Hot Reload_ enabled, then the simulator will reload automatically), and you'll see something that looks like:

image::images/tweet-app-welcome-page-no-style.png[]

Now that the structure is there, let's work on the style.

Let's start with the _Create Account_ button.  According a web search, the _Twitter Blue_ color is `#1DA1F2`, so let's make the button background this _Twitter Blue_ and the foreground color white.  We'll do this by creating a UIID named `TwitterButton` in our stylesheet.

==== The _Create Account_ Button

Open the stylesheet (located at _src/main/css/theme.css_) and add the following:

[source,css]
----
TwitterButton {
    cn1-derive: Button;
    background-color: #55acee;
    color: white;
    border: cn1-pill-border;
}
----

And add `uiid="TwitterButton"` to the _Create Account_ button:

[source,xml]
----
<button uiid="TwitterButton">Create account</button>
----

You should see the simulator update within a couple seconds to show you the result of this change:

image::images/twitter-create-account-button-2.png[]

This is getting closer, but the button needs a bit more padding.

Just eye-balling it, I'd say the button has about an equal amount of padding as the text size.  So we'll try padding of `1rem`.

After some trial and error, I found that the it looks best with a padding of 0.7rem.

TIP: The `rem` unit corresponds to the height of the default system font.  You can also use other units such as `mm` (millimetres)`, `pt` (points = 1/72nd of an inch), `px` = pixels, `vh` = percent of the display height, `vw` = percent of the display width, `vmin` = percent of the minimum of the display height and width, or `vmax` = the percent of the maxium of the display height and width.

So our CSS becomes:

[source,css]
----
TwitterButton {
    cn1-derive: Button;
    background-color: #1DA1F2;
    color: white;
    border: cn1-pill-border;
    padding: 0.7rem;
    font-size: 1rem;
    font-family: 'native:MainBold';
    margin:0;
}
----

NOTE: I also explicitly set the _font-size_ and _font-family_ here.  The `native:MainBold` maps to the main bold font of the platform.  On Android this will be the _Roboto_ font, and on iOS it will be the _San Francisco_ font.

And the result looks like the following:

image::images/tweetapp-create-account-button-3.png[]

==== The Form Padding

We also need to add some padding to the form to match the design.  Again, I'm eye-balling it, but it looks like their form has about 10% of the display width.

Create a new UIID in the stylesheet and call it WelcomePage as follows:

[source,css]
----
WelcomePage {
    padding:10vw;
}
----

You should see the result instantly in the simulator:

image::images/tweetapp-create-account-button-4.png[]

It's getting closer.  The font isn't exactly right (I'm just using the defualt font right now), but that's OK.  We can circle back and refine the fonts later.

==== The Heading Text

The next obvious thing is the _See what's happening..._ text.  This needs to be larger and black.

I'll create a style named _TwitterHeading1_ for this style.  Set this style as the `textUIID` attribute on the `<spanLabel>` tag:

[source,xml]
----
<spanLabel textUIID="TwitterHeading1">See what's happening in the world right now.</spanLabel>
----

NOTE: We set the `textUIID` attribute instead of the usual `uiid` attribute because the _SpanLabel_ component is a compound component that contains an inner component for rendering the text.  The `uiid` attribute, in this case, only pertains to the outer `SpanLabel` container - so things like borders, backgrounds, and padding, will work as expected there - but the _font_ needs to be applied to the inner component.

And add this style to the stylesheet:

[source,css]
----
TwitterHeading1 {
    font-size: 1.2rem;
    color: black;
    margin-bottom: 1rem;
}
----

These sizes and margins were arrived at by trial and error.

According to the simulator, we're getting closer to our destination:

image::images/tweetapp-create-account-button5.png[]

==== The Login Link

The footer text and login link are currently too big, and require some padding.  They also highlight a problem that we will face when app is displayed on a phone that has rounded corners and notches, like the iPhone X.

We'll add the `safeArea="true"` attribute on the view's container to ensure that it provides enough padding so that its contents don't get clipped by the corners and notches.

[source,xml]
----
<borderAbsolute safeArea="true" ...>
----


We'll also add some styles for the bottom labels and links, we'll call them, `TwitterSmallLabel` and `TwitterSmallLink` respectively.

[source,css]
----
TwitterSmallLabel {
    cn1-derive: Label;
    font-size: 0.5rem;
    padding:0;
    margin:0;
    color: #66757f;
    margin-right: 1mm;
}

TwitterSmallLink {
    cn1-derive: Button;
    font-size: 0.5rem;
    padding:0;
    margin:0;
    color: #1DA1F2;
}
----

These values were arrived at via trial-and-error, per usual.

NOTE: The `cn1-derive` directive means that this style inherits all of the styles from the given style. E.g. `TwitterSmallLabel` _extends_ the `Label` style, which is defined in the native theme for the platform.

==== Hiding the Title Area

The design doesn't include a typical title bar, but our view currently displays a small white area across the top of the form that from the title that we aren't using.  We can hide this title area by adding:

[source,xml]
----
<title hidden="true"/>
----

==== Background Color

Our background color is currently just using the default form background color which is grayish.  We need to change it to _white_.  We can do that by adding `background-color:white` to the `WelcomePage` style in the stylesheet:

[source,css]
----
WelcomePage {
    padding: 10vw;
    background-color: white;
}
----

image::images/tweetapp-welcome-form-almost-complete.png[]

==== The Title Bar Icon

While this view doesn't have a conventional title bar, it does display the _Twitter_ icon in the _title_ position at the top of the form.  Rather than copy the _real_ twitter icon I had our designer make up a custom icon for our tweet app:

image::images/tweet-app-icon-screenshot.png[]

At my request, he wrapped this icon in a TTF file so that it can be used as an icon font within my application.

TIP: My designer used https://icomoon.io/[IcoMoon] to convert his vector image into a truetype font.

TODO: Add a link to download the .ttf font

To use this font, I created a _fonts_ directory inside the _css_ directory, and copied the font (named _icomoon.ttf_) there, so that the font is located at _src/main/css/fonts/icomoon.ttf_.

image::images/tweetapp-css-fonts-folder.png[]

To use this font in the app, I need to add a `@font-face` directive for the font inside the stylesheet as follows:

[source,css]
----
@font-face {
  font-family: 'icomoon';
  src: url('fonts/icomoon.ttf');
}
----

I also need to create a style that uses this font:

[source,css]
----
TwitterIcon {
    font-family: icomoon;
    font-size: 1.4rem;
    color: #1DA1F2;
}
----

Now, I can finally add a label to my view that uses this icon font, as a means to display the icon.

[source,xml]
----
<center layout-constraint="north">
    <label iconUIID="TwitterIcon" fontIcon="(char)0xe902" ></label>
</center>
----

NOTE: In this version it was necessary to cast the `0xe902` to `char` to avoid a compiler error.  In future versions, this cast will no longer be required.

I use the `iconUIID` attribute to set the UIID of the label's icon so that it uses the our font icon.  The `fontIcon` attribute specifies the character code of the glyph in the font to display. In this case it is the unicode character 0xe902, which I was able to extract from the files provided by IcoMoon.

==== Final Result

.The final result of our WelcomePage
image::images/tweetapp-welcome-page-final-result.png[]

.WelcomePage.xml
[source,xml]
----
<?xml version="1.0"?>
<borderAbsolute
        uiid="WelcomePage"
        safeArea="true"
        xsi:noNamespaceSchemaLocation="WelcomePage.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

    <title hidden="true"/>
    <center layout-constraint="north">
        <label iconUIID="TwitterIcon" fontIcon="(char)0xe902" ></label>
    </center>

    <y layout-constraint="center">
        <spanLabel textUIID="TwitterHeading1">See what's happening in the world right now.</spanLabel>
        <button uiid="TwitterButton">Create account</button>

    </y>

    <flow layout-constraint="south">
        <label uiid="TwitterSmallLabel">Have an account already?</label>
        <button uiid="TwitterSmallLink">Log in</button>

    </flow>
</borderAbsolute>
----

.theme.css
[source,css]
----
#Constants {
    includeNativeBool: true;
}

@font-face {
  font-family: 'icomoon';
  src: url('fonts/icomoon.ttf');
}

TwitterButton {
    cn1-derive: Button;
    background-color: #1DA1F2;
    color: white;
    border: cn1-pill-border;
    padding: 0.7rem;
}

WelcomePage {
    padding:10vw;
    background-color:white;
}

TwitterHeading1 {
    font-size: 1.2rem;
    color: black;
    margin-bottom: 1rem;
}

TwitterSmallLabel {
    cn1-derive: Label;
    font-size: 0.5rem;
    padding:0;
    margin:0;
    color: #66757f;
    margin-right: 1mm;
}

TwitterSmallLink {
    cn1-derive: Button;
    font-size: 0.5rem;
    padding:0;
    margin:0;
    color: #1DA1F2;
}

TwitterIcon {
    font-family: icomoon;
    font-size: 1.4rem;
    color: #1DA1F2;
}
----

==== Adapting for Android

But wait, we're not done yet.  So far we've been testing with the _iPhone X_ skin exclusively.  Since we are building our app for multiple platforms, we need to test it on some other skins.  The Codename One simulator comes with skins for many popular phone and tablets on the market.  By default, you'll only see the _iPhoneX_ and desktop skins in the _Skins_ menu.  You can add additional skins via the _Skins_ > _More..._ menu item.

My favourite Android skin is the Samsung Galaxy S8.  If your _Skins_ menu doesn't include this skin yet, then you'll need to add it, as follows.

. Select _Skins_ > _More..._ from the menu bar.
+
image::images/skins-add-more-menuitem.png[]
+
It will take a few seconds to load the list of skins.
. When the _Skins_ dialog appears, enter "GalaxyS" into the search field at the top.  You should see a few matching results appear in the list, as shown below:
+
image::images/skins-galaxy-search.png[]
+
NOTE: _SamsungGalaxyS8_ is not included in the screenshot above because I have already installed it, but it should appear in your list.
. Check the box beside _SamsungGalaxyS8_, and press the _Download_ button.
+
It will take a few moments, but when it is done, you should see an option for _SamsungGalaxyS8_ in your skins menu.

To test out the app in Android, select the _SamsungGalaxyS8_ skin from the _Skins_ menu.

image::images/select-galaxys8-skin.png[]

It should resemble the screenshot below:

image::images/tweetapp-android-skin-1.png[]

This looks a little different than it did on the iPhoneX skin. All of the text is a little bit too small.

This is because different platforms have different default font sizes, and pixel density also varies across devices.  The best way I have found to _normalize_ these factors and obtain consistent results across platform is to define the `defaultFontSize` theme constant to an appropriate value, and use `rem` units for font sizes whenever possible.

In the `#Constants` section of the _theme.css_ file, add:

[source,css]
----
#Constants {
  ...
  defaultFontSizeInt: 18;
}
----

We are also going to change some of the font sizes so that they look better on the _S8_ skin.

Change the `font-size` properties in a few styles as follows:

[source,css]
----
TwitterButton {
  ...
  font-size: 1rem;
}

TwitterHeading1 {
  ...
  font-size: 1.5rem;
}

TwitterSmallLabel {
  ...
  font-size: 0.7rem;
}

TwitterSmallLink {
  ...
  font-size: 0.7rem;
}
----

After making these changes, the simulator should look something like:

image::images/tweet-app-s8-skin-2.png[]

And if we now toggle back to the iPhone X, it will look like:

image::images/tweetapp-iphonex-skin-final.png[]

These now look a little better.

We may continue to tweak the styles as we go on, but for now, I'd say we can move onto the registration page.

=== The Signup Page

When you click on _Create account_ in the _Twitter_ app, it brings you to the _Signup Page_ which looks like:

image::images/twitter-signup-page.png[]

Create a new file named "SignupPage.xml" in the same directory as the _WelcomePage.xml_ file.

Then add the following contents:

[source,xml]
----
<?xml version="1.0"?>
<border safeArea="true"
        xsi:noNamespaceSchemaLocation="SignupPage.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <title>
        <label iconUIID="TwitterIcon" fontIcon="(char)0xe902" ></label>
    </title>
    <y layout-constraint="center">
        <label>Create your account</label>
        <textField hint="Name"/>
        <textField hint="Phone number or email address"/>
        <textField hint="Date of birth"/>
    </y>
    <right layout-constraint="south">
        <button>Next</button>
    </right>
</border>

----

NOTE: I used `<textField>` tags for all three fields of this form, even though (as we'll discover later) the _birthdate_ field should be a date picker, and the _phone number or email address_ field has more involved than a single _TextField_ component can handle.  Later on we will be revisiting these tag choices, but for now I just want to be able to express the semantic structure of the form using tags.  It will be easy to change them to different components later on if required.

This is just a basic set of components to replicate the contents of the form.  It doesn't include any special styling yet.  There are a couple of things worth noting here:

In the _WelcomePage_ we hid the title bar using `<title hidden="true"/>`.  Since this form has a _back_ button, however, I'd like to use the default title bar so that we can get the _back_ functionality for free.

The `<title>` is a special tag that test the title of the form.  If you provide string contents, then those will be used as the title.  If you provide a child component, as we've done here, it will use that component in the title position.  In this case we want our icon to be placed in the title position.

The `<right>` tag is an alias for a container with `FlowLayout` and aligned to the right.

==== Linking from the Welcome Page

Before we can try out our new _Signup_ page, we need to add a link to it from the _Welcome_ page.  We'll do this by adding a `rad-href` attribute to the _Create account_ button on the _Welcome_ page:

[source,xml]
----
<button uiid="TwitterButton" rad-href="#SignupPage">Create account</button>
----

Now, when you click on the _Create account_ button, it will navigate to our new _Signup_ page, which is shown below:

image::images/tweetapp-signup-page-1.png[]

This is a starting point.

==== Hot Reload: Reload Current Form

Before we begin the process of styling the _Signup_ form, let's change the _Hot Reload_ settings of the simulator to _Reload Current Form_.  This will cause the app to automatically reload the current form when we make changes triggering the hot reload.

image::images/hot-reload-reload-current-form.png[]

NOTE: When the _Reload Current Form_ option is enabled we lose the navigation context on reload, so things like the _Back_ button won't appear.

This mode is helpful while we are actively developing a view.

==== Adding Styles

I won't go through the _styling_ process in as much detail as I did for the _Welcome_ page.  I'll just show you the styles I arrived at by trial and error, and comment on some of the new or non-obvious things.  Add the following styles to your stylesheet:

[source,css]
----

/** Signup Page Styles */

SignupPage {
    background-color:white;
    margin:0;
}

SignupPageContent {
    padding: 8vw;
}

SignupPageTitle {
    cn1-derive: Label;
    font-size: 1.2rem;
    font-family: "native:MainBold";
    text-align:center;
    margin-bottom: 1.7rem;
    color: black;
}

TwitterNextButton {
    cn1-derive: Button;
    background-color: #1DA1F2;
    color: white;
    border: cn1-pill-border;
    padding: 0.5rem 0.75rem;

    font-size: 0.7rem;

}

TwitterTextField, TwitterTextFieldHint {
    padding-top: 0.7rem;
    padding-bottom: 0.7rem;
    font-size: 0.8rem;
    font-family: "native:MainLight";
}

TwitterTextField {
    cn1-derive: TextField;
    border: none;
    border-bottom: 0.8pt solid #ccc;

    margin-top: 1rem;
    margin-bottom: 0.5rem;


}

TwitterTextFieldHint {
    color: #66757f;

}
----

And set the UIIDs for the corresponding elements in the _SignupPage_ view:

[source,xml]
----
<?xml version="1.0"?>
<border uiid="SignupPage"
        safeArea="true"
        xsi:noNamespaceSchemaLocation="SignupPage.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <title>
        <label iconUIID="TwitterIcon" fontIcon="(char)0xe902" ></label>
    </title>
    <y layout-constraint="center" uiid="SignupPageContent">
        <label uiid="SignupPageTitle">Create your account</label>
        <textField hint="Name" uiid="TwitterTextField" hintLabel.uiid="TwitterTextFieldHint"/>
        <textField hint="Phone number or email address" uiid="TwitterTextField" hintLabel.uiid="TwitterTextFieldHint"/>
        <textField hint="Date of birth" uiid="TwitterTextField" hintLabel.uiid="TwitterTextFieldHint"/>
    </y>
    <right layout-constraint="south">
        <button uiid="TwitterNextButton">Next</button>
    </right>


</border>

----

The things to notice on this snippet are the `uiid` attributes that were added to some of the XML tags.  Notice also that I added `hintLabel.uiid` attributes to the `<textField>` tags.  These are to set the UIID of the _hint_ text and correspond with the _Java_ expression `textField.getHintLabel().setUIID(...)`.  This demonstrates the syntax that you can use to set _sub_-properties via attributes.

TIP: There is no limit to the number of levels of chaining  that you can do with setting sub-properties.  E.g. `a.b.c.d.e="foo"` would be the same as calling, `theComponent.getA().getB().getC().getD().setE(foo)` in Java, except that the code that CodeRAD generates is null-safe.  _However_, not all chaining sequences are included in the XML schemas, so IntelliJ highlight some of your chained attributes in red, claiming that they are invalid.  While this may be annoying (seeing the error message), the view should build just fine.

The result on the Samsung Galaxy S8:

image::images/tweetapp-signup-form-s8-2.png[]

And on iPhone X:

image::images/tweetapp-signup-form-iphonex-2.png[]

==== The Title Bar

We didn't explicitly create the title bar with an XML tag.  Its creation is handled by the `FormController` when the view is displayed.  Therefore we couldn't set a `uiid` attribute to set its style.  This is why it looks a little off color on the iPhoneX, and it has a shadowed bottom border on the S8.

In cases like this, when I need to style a component that I didn't create myself, I generally use the _Component Inspector_ in the simulator to find out the UIID of the "offending" component.  Let's do that now, by selecting _Tools_ > _Component Inspector_:

image::images/tweetapp-component-inspector-menu.png[]

The screenshot below shows the component tree expanded to the _TitleBar_ component.  The component that I select in the component tree is shaded _red_ in the simulator, which helps me to know that I have found the correct component.

image::images/tweetapp-component-inspector-titlearea.png[]

According to the inspector, the UIID of that component is "TitleArea", so let's try to override that style in the stylesheet.

Global overrides like this I usually place near the beginning of the stylesheet.

[source,css]
----
TitleArea {
    border:none;
    background-color:white;
    margin:0;
}
----

And the result on the S8:

image::images/tweetapp-signup-page-s8-4.png[]

==== The Signup Page Controller

Our next step is to make make the signup page actually do something other than look pretty.  In the spirit of MVC we will handle logic for this form in a _controller_.

Create a _com.example.tweetapp.controllers_ package inside the _src/main/java_ directory if you haven't already, and create a new Java class in this package named "SignupPageViewController" with the following contents:

[source,java]
----
package com.example.tweetapp.controllers;

import com.codename1.rad.controllers.Controller;
import com.codename1.rad.controllers.ViewController;

public class SignupPageViewController extends ViewController {
    /**
     * Creates a new ViewController with the given parent controller.
     *
     * @param parent
     */
    public SignupPageViewController(Controller parent) {
        super(parent);
    }
}

----

Then, back in the _SignupPage.xml_ view, add a `view-controller` attribute to the root XML tag that referrs to the _SignupPageViewController_ class:

[source,xml]
----
<border view-controller="com.example.tweetapp.controllers.SignupPageViewController" ... >
...
----

==== The "Next" Action

Now that we have our view controller in place, let's convert the _Next_ button into a _Next_ action - the distinction being that an action is _bound_ to the controller.

First we need to add an action category for the _Next_ action.  We do this via the `<define-category>` tag:

[source,xml]
----
<define-category name="NEXT"/>
----

TIP: If the `<define-category>` tag is new to you, you should check out <<adding-actions>> in the _Getting Started_ section for a brief introduction to actions and categories.

And we'll bind our _Next_ button to this _NEXT_ category using the `<bind-action>` tag, which we'll add as a child of the `<button>` tag:

[source,xml]
----
<button uiid="TwitterNextButton" text="Next">
    <bind-action category="NEXT"/>
</button>
----

Notice we moved the "Next" text from the tag content into the `text` attribute.  This is just cleaner to look at now that we have some child tags.

NOTE: When `<bind-action>` is added to a `<button>`, properties defined in the action will override the corresponding button properties.  E.g. If the action included a `label` property, then that would override the `text` attribute of the `button`.

Now to define the _Next_ action in the controller.

Implement the `initControllerActions()` method in the view controller as follows:

[source,java]
----
@Override
protected void initControllerActions() {
    super.initControllerActions();

    ActionNode.builder()
            .addToController(this, SignupPage.NEXT, evt->{
                evt.consume();
                Dialog.show("Click recieved", "You clicked Next", "OK", null);
            });
}
----

The `ActionNode.builder()` method creates an `ActionNode.Builder` object, which has many utility methods for constructing actions and registering them with controllers.

The `addToController()` method takes three parameters:

. The controller to add the action to.  In this case we pass `this` since we want to add it to this view controller.
. The Action Category.  In this case we are passing `SignupPage.NEXT` which was generated by our `<define-category name="NEXT"/>` tag.
. An `ActionListener` that is called when the action is triggered.  In this case we just display a dialog that says "You Clicked Me".

If you reload the app in simulator and press the "Next" button, it should display a dialog as shown here:

.Dialog shown when clicking the _Next_ button on Android.  Notice that this dialog uses the native Android styles.  On iOS the dialog would look slightly different - matching the iOS native theme.
image::images/tweetapp-next-you-clicked-me-android.png[]

==== The View Model

Now, when the user clicks _Next_ it triggers the corresponding event handler in our controller, but we haven't provided a "clean" way, yet, to pass the user's input to our controller action.  This is where the _view model_ comes into play.

The _View Model_ is the entity object that stores all of the model data for a view.  If you do not explicity specify a view model for your view (via the `rad-model` attribute), then an Entity class is automatically generated by the CodeRAD annotation processor, named `{ViewName}Model`.  E.g. For our `SignupPage` view, the generated entity class would be named `SignupPageModel`, and it would be in the same package as the `SignupPage` view.

You can define properties for the view model using the `<define-tag>` tag, as described in <<implicit-view-models>>.

In our case, we are going to add properties for each field on the form.

Add the following to the _SignupPage.xml` view anywhere inside the root tag. I generally place my `define-tag` tags near the top.

[source,xml]
----
<define-tag name="name" value="Person.name"/>
<define-tag name="phone" value="Person.telephone"/>
<define-tag name="email" value="Person.email"/>
<define-tag name="birthDate" value="Person.birthDate" type="java.util.Date"/>
----

A few things to note here:

. I have provided a `value` attribute for each of these tags because these properties seem to match up directly with well-known property types.  CodeRAD includes a set of default schemas in the _com.codename1.rad.schemas_ directory which are adapted from the schemas listed at https://schema.org/.  In particular the https://schema.org/Person[Person schema] seems relevant here. By mapping our properties to these existing properties, it will make it easier for other views to use our view model without having to explicitly depend on the view model entity itself. See <<entities-properties-schemas-tags>> for some more information about this.
. For the `birthDate` tag we have added a type of `java.util.Date`.  If no type is required, the property is assumed to be a string.  Since the _birthDate_ is a date, we want the model to treat this property as a date.
. I have split up the "Phone or Email Address" field into two properties: _phone_ and _email_.  This is just cleaner.  Also, as we'll see, the _Phone or Email_ field of the Twitter app isn't really a _single_ text field at all.  It is more like a button that toggles between two different possible text fields: phone and email.

==== Binding UI Elements to the View Model

Now that we have a view model in place, we can bind our UI elements to the model.  This will involve changing the `<textField>` tags that we are currently using to their "bindable" counterparts.  We will also take this opportunity to split up the "Phone or Email" field up into two fields.

CodeRAD includes a set of bindable wrappers for most of the core Codename One components in the _com.codename1.rad.propertyviews_ package.  To convert a basic Codename One component to its bindable counterpart, you can generally prefix "rad" to the tag name.  E.g. Instead of `<textField>`, you can use `<radTextField>`.

A slight wrinkle is that the `<rad*>` components are actually `Container` classes that _wrap_ the basic component, so if you want to set properties on the basic component such as "hint" or "uiid", you need to set them with the "component." prefix.

For example, let's convert the _name_ text field into its RAD counter part.  Before we had:

[source,xml]
----
<radTextField
  hint="Name"
  uiid="TwitterTextField"
  hintLabel.uiid="TwitterTextFieldHint"
/>
----

We change this to:

[source,xml]
----
<radTextField
  tag="name"
  component.hint="Name"
  component.uiid="TwitterTextField"
  component.hintLabel.uiid="TwitterTextFieldHint"
/>
----

Notes on this:

. The `tag="name"` binds this component to the "name" property of the view model that we defined above using `<define-tag../>`.
. We prefixed each of the attributes that target the _TextField_ itself with "component."  This is beause the TextField itself is actually wrapped by the `radTextField` (which is an instance of `TextFieldPropertyView`), and the rad text field class has a `getComponent()` method that retrieves the actual text field.  So, for example, setting `component.hint="Name"` is like calling `radTextField.getComponent().setHint("Name")`.


























