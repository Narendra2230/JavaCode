== Getting Started

To get started, download the CodeRAD starter project from https://github.com/shannah/coderad2-starter-template/archive/refs/heads/master.zip[here].

Extract the .zip file and then open the project in IntelliJ IDEA

NOTE: The CodeRAD starter project is a maven project which can be opened in any Maven-compatible IDE (e.g. NetBeans, Eclipse, IntelliJ, etc...).  For this tutorial, I'll be using IntelliJ.

.The Code RAD starter project opened in IntelliJ IDEA
image::images/intellij-starter-project.png[]

Once the project is opened, press the
image:images/intellij-run-button.png[]
 icon on the toolbar to run the project in the Codename One simulator.

NOTE: The first time you run and build the project it will take some time because it needs to download all of the project dependencies.  Subsequent builds should only take a few seconds.

.The starter project running inside the Codename One simulator
image::images/hello-world-in-simulator.png[]

.Under the Hood
****
Let's take look under the hood to see how this "Hello World" app is producted.

The _starting point_ for your app is the `com.example.myapp.MyRADApp` class, located in the _common/src/main/java_ directory.

image::images/hello-world-main-class-project-inspector.png[]

The contents are shown below:

[source,java]
----
package com.example.myapp;

/*.. imports omitted ...*/

public class MyRADApp extends ApplicationController {

    public void actionPerformed(ControllerEvent evt) {
        with(evt, StartEvent.class, startEvent -> {
            startEvent.setShowingForm(true);
            new StartPageController(this).show();
        });
        super.actionPerformed(evt);
    }
}
----

This class overrides https://www.javadoc.io/doc/com.codenameone/coderad-common/latest/com/codename1/rad/controllers/ApplicationController.html[ApplicationController], and listens for the _StartEvent_, which is fired when the app starts, or is brought to the foreground.

The effective action performed by the event handler is the line:

[source,java]
----
new StartPageController(this).show();
----

This creates a new _StartPageController_ and shows it.

The _StartPagePageController_ class is a https://www.javadoc.io/doc/com.codenameone/coderad-common/latest/com/codename1/rad/controllers/FormController.html[FormController] subclass that is generated from the _StartPage_ view at compile-time by the CodeRAD annotation processor.

The _StartPage_ view is implemented as a RAD View using XML.  It is located inside the _common/src/main/rad/views_ directory.

image::images/starter-app-rad-views-hierarchy.png[]

The contents are shown below:

[source,xml]
----
<?xml version="1.0"?>
<y xsi:noNamespaceSchemaLocation="StartPage.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <title>Hi World</title>
    <label>Hello World</label>
</y>
----

TIP: The boilerplate attributes `xsi:noNamespaceSchemaLocation="StartPage.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"` are injected automatically by the annotation processor.  You can leave those out when you create your own views.

Let's walk through this file line by line:

`<?xml version="1.0"?>`::
Obligatory XML boilerplate.
`<y>`::
A Container with `BoxLayout.Y` layout.  (i.e. a container that lays out its children vertically).
`<title>Hi World</title>`::
Not a child component, rather a "bean" that sets the title of the form to "Hi World"
`<label>Hello World</label>`::
A Label component with the text "Hello World"

****

=== Hot Reload

The Codename One simulator supports a "Hot Reload" feature that can dramatically improve productivity.  Especially if you're like me, and you like to experiment with the UI by trial and error.

Hot Reload is disabled by default, but you can enable it using the _Tools_ > _Hot Reload_ > _Reload Simulator_ option (From the Simulator's menu bar).

image::images/enable-hot-reload.png[]

If the _Reload Simulator_ option is checked, then the simulator will monitor the project source files for changes, and automatically recompile and reload the simulator as needed.

TIP: Technically the _Reload Simulator_ option isn't a hot reload, since it actually restarts the simulator - and you will lose your place in the app.  True hot reload (where the classes are reloaded transparently without having to restart the simulator) is also available, but it is experimental and requires some additional setup.

**The remainder of this tutorial will assume that you have _Hot Reload_ enabled**

=== Changing the Styles

Keep the simulator running, and open the CSS style stylesheet for the project, located at _common/src/main/css/theme.css_.

image::images/theme-css-project-inspector.png[]

Add the following snippet to the _theme.css_ file:

[source,css]
----
Label {
  color: blue;
}
----

Within a second or two after you save the file, you should notice that the "Hello World" label in the simulator has turned blue.

image::images/hello-world-blue.png[]

This is because the https://www.codenameone.com/javadoc/com/codename1/ui/Label.html[Label] component's default UIID is "Label", so it adopts styles defined for the selector "Label" in the stylesheet.

[TIP]
====
If you are unsure of the UIID of a particular component, you can use the component inspector in the simulator to find out. Select _Tools_ > _Component Inspector_

image::images/component-inspector-menu.png[]

In the _Component Inspector_, you can expand the component tree in the left panel until you reach the component you're looking for.  The details of that component will then be shown in the right panel.

image::images/component-inspector-label-details.png[]

The _UIID_ field will show you the UIID of the component that you can use to target the component from the stylesheet.

====

The above stylesheet change will change the color of _all_ labels to _blue_.  What if we want to change only the color of _this_ label without affecting the other labels in the app?  There are two ways to do this.  The first way is to override the _fgColor_ style inline on the `<label>` tag itself.

==== Inline Styles

In the _StartPage.xml_ file, add the `style.fgColor` attribute to the `<label>` tag with the value "0xff0000".

.In IntelliJ's XML editor, you'll receive type hints for all tags and attributes as shown here.
image::images/xml-attribute-style-fgColor-typehints.png[]

Notice that, as soon as you start typing inside the `<label>` tag, the editor presents a drop-down list of options for completion.  This is made possible by the schema (StartPage.xsd located in the same directory as your StartPage.xml file) that the CodeRAD annotation processor automatically generates for you.  This schema doesn't include _all_ of the possible attributes you can use, but it does include most of the common ones.

After making the change, your _StartPage.xml_ file should look like:

[source,xml]
----
<?xml version="1.0"?>
<y xsi:noNamespaceSchemaLocation="StartPage.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <title>Hi World</title>
    <label style.fgColor="0xff0000">Hello World</label>
</y>
----

And, within a couple of seconds, the simulator should have automatically reloaded your form - this time with "Hello World" in _red_ as shown below.

image::images/simulator-hello-world-red.png[]

If it doesn't automatically reload your form, double check that you have _Hot Reload_ enabled (See the _Tools_ > _Hot Reload_ menu).  If _Hot Reload_ is enabled and it still hasn't updated your form, check the console output for errors.  It is likely that your project failed to recompile; probably due to a syntax error in your _StartPage.xml_ file.

.XML Tag Attributes
****
In the above example, we added the `style.fgColor` attribute to the `<label>` tag to set its color.  This attribute corresponds to the following Java snippet on the label:

[source,java]
----
theLabel.getStyle().setFgColor(0xff0000);
----

In a similar way, you can set any property via attributes that can be accessed via a chain of "getters" from the label, as long as the end of the chain has an appropriate "setter".  The _Label_ class includes a "setter" method `setPreferredH(int height)`.  You could set this via the `preferredH` property e.g.:

[source,xml]
----
<label preferredH="100"/>
----

would correspond to the Java:

[source,java]
----
theLabel.setPreferredH(100)
----

In the `style.fgColor` example, the `style` portion corresponded to the `getStyle()` method, and the `fgColor` component corresponded to the `setFgColor()` method of the `Style` class.  The `Label` class also has a `getDisabledStyle()` method that returns the style that is to be used when the label is in "Disabled" state.  This isn't as relevant for `Label` as it would be for active components like `Button` and `TextField`, but we could set it using attributes.  E.g.

[source,xml]
----
<label disabledStyle.fgColor="0xff0000">Hello World</label>
----

or All styles (which sets the style for all of the component states at once):

[source, xml]
----
<label allStyles.fgColor="0xff0000">Hello World</label>
----

This sidebar is meant to give you an idea of the attributes that are available to you in this XML language, however, we haven't yet discussed the vocabulary that is available to you for the attribute values.  So far the examples have been limited to _literal_ values (e.g. `0xff0000`), but this is just for simplicity.  Attributes values can be any valid Java expression in the context.  See the section on "Attribute Values" for a more in-depth discussion on this, as there are a few features and wrinkles to be aware of.

****

==== Custom UIIDs

The second (preferred) way to override the style of a particular Label without affecting other labels in the app is to create a custom UIID for the label.

Start by changing the `Label` style in your stylesheet to `CustomLabel` as follows:

[source,css]
----
CustomLabel {
  cn1-derive: Label;  <1>
  color: blue;
}
----
<1> The `cn1-derive` directive indicates that our style should "inherit" all of the styles from the "Label" style.

Now return to the _StartPage.xml_ file and add `uiid="CustomLabel"` to the `<label>` tag.  While we're at it, remove the inline `style.fgColor` attribute:

[source,xml]
----
<label uiid="CustomLabel">Hello World</label>
----

Finally, to verify that our style only affects this single label, let's add another label to our form without the `uiid` attribute.  When all of these changes are made, the _StartPage.xml_ content should look like:

[source,xml]
----
<?xml version="1.0"?>
<y xsi:noNamespaceSchemaLocation="StartPage.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <title>Hi World</title>
    <label uiid="CustomLabel">Hello World</label>
    <label>A regular label</label>
</y>
----

After saving both _theme.css_ and _StartPage.xml_, the simulator should automatically reload, and you'll see something like the following:

image::images/simulator-hello-world-custom-uiid.png[]

=== Adding More Components

So far we've only used the `<label>` tag, which corresponds to the `Label` component.  You are not limited to `<label>`, nor are you limited to any particular subset of "supported" components.  You can use _any_ Component in your XML files that you could use with Java or Kotlin directly.  You can even use your own custom components.

The tag name will be the same as the simple class name of the component you want to use.  By convention, the tag names begin with a lowercase letter.  E.g. The _TextField_ class would correspond to the `<textField>` tag.

.XML Tag Namespaces
****
Since XML tags use only the _simple_ name for its corresponding Java class, you may be wondering how we deal with name collisions. For example, what if you have defined your own component class _com.xyz.widgets.TextField_.  Then how would you differentiate this class from the _com.codename1.ui.TextField_ class in XML.  Which one would `<textField>` create?

The mechanism of differentiation here is the same as in Java.  Each XML file includes a set of _import_ directives which specify the package namespaces that it will search to find components corresponding with an XML tag.  It small selection of packages are imported "implicitly", such as _com.codename1.ui_, _com.codename1.components_, _com.codename1.rad.ui.propertyviews_, and a few more.  If you want to import _additional_ packages or classes, you can use the `<import>` tag, and include regular Java-style import statements as its contents.

E.g.

[source,xml]
----
<?xml version="1.0" ?>
<y>
  <import>
  import com.xyz.widgets.TextField;
  </import>

  <!-- This would create an instance of com.xyz.widgets.TextField
       and not com.codename1.ui.TextField -->
  <textField/>
</y>
----

*You can include any valid Java import statement inside the `<import>` tag.*

E.g. the following mix of package and class imports is also fine:

[source,xml]
----
<import>
import com.xyz.widgets.TextField;
import com.xyz.otherwidgets.*;
</import>
----
****

For fun, let's try adding a few of the core Codename One components to our form to spice it up a bit.

[source,xml]
----
<?xml version="1.0"?>
<y scrollableY="true" xsi:noNamespaceSchemaLocation="StartPage.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <title>Hi World</title>
    <label uiid="CustomLabel">Hello World</label>
    <label>A regular label</label>

    <!-- A text field with a hint -->
    <textField hint="Enter some text"></textField>

    <!-- A text field default text already inserted -->
    <textField>Some default text</textField>

    <!-- A password field -->
    <textArea constraint="TextArea.PASSWORD"/>

    <!-- Multiline text -->
    <spanLabel>Write Once, Run Anywhere.
        Truly native cross-platform app development with Java or Kotlin for iOS, Android, Desktop &amp; Web.
    </spanLabel>

    <!-- A Calendar -->
    <calendar/>

    <checkBox>A checkbox</checkBox>

    <radioButton>A Radio Button</radioButton>

    <button>Click Me</button>

    <spanButton>Click
    Me</spanButton>

    <multiButton textLine1="Click Me"
        textLine2="A description"
                 textLine3="A subdesc"
                 textLine4="Line 4"
    />



</y>
----

After changing the contents of your _StartPage.xml_ file to the above, and saving it, you should see the following result in the simulator:

image::images/simulator-fun-with-components.png[]

=== Adding Actions

CodeRAD is built around the Model-View-Controller (MVC) philosophy which asserts that the _View_ logic (i.e. how the app looks) should be separated from the _Controller_ logic (i.e. what the app does with user input).  _Actions_ form the cornerstone of how CodeRAD keeps these concerns separate.  They provide a sort of communication channel between the controller and the view, kind of like a set of Walkie-talkies.

To go with the Walkie-talkie metaphor for a bit, A View will broadcast on a few frequencies that are predefined by the View.  It might broadcast on 96.9MHz when the "Help" button is pressed, and 92.3MHz when text is entered into its _username_ text field.

Before displaying a View, the Controller will prepare a set of one-way Walkie-talkies at a particular frequency.  It passes one of the handset's to the view - the one that _sends_.  It retains the other handset for itself - the one that receives.

When the view is instantiated, it will look through all of the walkie-talkie handsets that were provided and see if any are set to a frequency that it wants to broadcast on.  If it finds a match, it will use it to broadcast relevant events.  To continue with the example, if finds a handset that is tuned to 96.9MHz, it will send a message to this handset whenever the "Help" button is pressed.

When the controller receives the message in the corresponding hand-set of this walkie-talkie, it can respond by performing some action.

The view can also use the set of Walkie-talkies that it receives to affect how it renders itself.  For example, if, when it is instantiated, it doesn't find any handsets tuned to 96.9MHz, it may "choose" just to not render the "Help" button at all, since nobody is listening.

Additionally, the Controller might attach some additional instructions to the handset that it provides to the view.  The view can then use these instructions to customize how it renders itself, or how to use the handset.  For example, the handset might come with a note attached that says "Please use _this_ icon if you attach the handset to a button", or "Please use _this_ text for the label", or "Please disable the button under this condition".

In the above metaphor, the _frequency_ represents an instance of the `ActionNode.Category` class, and the walkie-talkies represent an instance of the `ActionNode` class.  The _View_ declares which _Categories_ it supports, how it will interpret them.  The _Controller_ defines _Actions_ and registers them with the view in the prescribed categories.  When the _View_ is instantiated, it looks for these actions, and will use them to affect how it renders itself.  Typically actions are manifested in the View as a button or menu item, but not necessarily.  `EntityListView`, for example, supports the `LIST_REFRESH_ACTION` and `LIST_LOAD_MORE_ACTION` categories which will broadcast events when the list model should be refreshed, or when more entries should be loaded at the end of the list.  They don't manifest in any particular button or menu.

==== Adding our first action

Let's begin by restoring the _StartPage.xml_ template to its initial state:

[source,xml]
----
<?xml version="1.0"?>
<y scrollableY="true" xsi:noNamespaceSchemaLocation="StartPage.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <title>Hi World</title>
    <label>Hello World</label>
</y>
----

Now, let's define an action category using the `<define-category>` tag.

[source,xml]
----
<?xml version="1.0"?>
<y scrollableY="true" xsi:noNamespaceSchemaLocation="StartPage.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <define-category name="HELLO_CLICKED" />
    <title>Hi World</title>
    <label>Hello World</label>
</y>
----

And then change the `<label>` to a `<button>`, and "bind" the button to the "HELLO_CLICKED" category using the `<bind-action>` tag:

[source,xml]
----
<?xml version="1.0"?>
<y scrollableY="true" xsi:noNamespaceSchemaLocation="StartPage.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <define-category name="HELLO_CLICKED" /> <1>
    <title>Hi World</title>
    <button>Hello World
        <bind-action category="HELLO_CLICKED"/>
    </button>

</y>
----
<1> The `define-category` tag will define an `ActionNode.Category` in the resulting Java View class with the given name.

When the simulator reloads after this last change you will notice that the "Hello World" button is not displayed.  You do not need to adjust your lenses.  This is _expected_ behaviour.  Since the button is bound to the "HELLO_CLICKED" category, and the controller hasn't supplied any actions in this category, the button will not be rendered.

Let's now define an action in the Controller with this category.  Open the _com.example.myapp.MyRadApp_ class and add the following method:

[source,java]
----
@Override
protected void initControllerActions() {
    super.initControllerActions();
    addAction(StartPage.HELLO_CLICKED, evt-> {
        evt.consume();
        Dialog.show("Hello", "You clicked me", "OK", null);
    });
}
----

The `initControllerActions()` method is where all actions should be defined in a controller.  This method is guaranteed to be executed before views are instantiated.    The `addAction()` method comes in multiple flavours, the simplest of which is demonstrated here.  The first parameter takes the `HELLO_CLICKED` action category that we defined in our view, and it registered an `ActionListener` to be called when that action is fired.

Calling `evt.consume()` is good practice as it signals to other interested parties that the event has been handled.  This will prevent it from propagating any further to any other listeners to the `HELLO_CLICKED` action.

The `Dialog.show()` method shows a dialog on the screen.

If you save this change, you should see the simulator reload with the "Hello World" button now rendered as shown below:

image::images/hello-world-with-button.png[]

And if you click on the button, it will display a dialog as shown here:

image::images/dialog-show-you-clicked-me.png[]

==== Customizing Action Rendering

In the previous example, the controller didn't make any recommendations to the view over how it wanted its _HELLO_CLICKED_ action to be rendered.  It simply registered an `ActionListener` and waited to be notified when it is "triggered".   Let's go a step further now, and specify an icon and label to use for the action.  We will use the `ActionNode.Builder` class to build an action with the icon and label that we desire, and add it to the controller using the `addToController()` method of `ActionNode.Builder`.

Change your `initControllerActions()` method to the following and see how the action's button changes in the simulator:

[source,java]
----
@Override
protected void initControllerActions() {
    super.initControllerActions();
    ActionNode.builder().
        icon(FontImage.MATERIAL_ALARM).
        label("Click Now").
        badge("2").
        addToController(this, StartPage.HELLO_CLICKED, evt -> {
            evt.consume();
            Dialog.show("Hello", "You clicked me", "OK", null);
        });
}
----
image::images/action-overridden-in-controller.png[]

There's quite a bit more that you can do with actions, but this small bit of foundation will suffice for our purposes for now.

=== Creating Menus

Whereas the `<button>` tag will create a single button, which can be optionally "bound" to a single action, the `<buttons>` renders multiple buttons to the view according to the actions that it finds in a given category.  Let's change the example from the previous section display a menu of buttons.  We will:

1. Define a new category called `MAIN_MENU`.
2. Add a `<buttons>` component to our view with `actionCategory="MAIN_MENU"`.
3. Define some actions in the controller, and register them with the new `MAIN_MENU` category.

[source,xml]
----
<?xml version="1.0"?>
<y scrollableY="true" xsi:noNamespaceSchemaLocation="StartPage.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <define-category name="HELLO_CLICKED"/>

    <define-category name="MAIN_MENU" />
    <title>Hi World</title>
    <button text="Hello World">
        <bind-action category="HELLO_CLICKED"/>
    </button>
    <buttons actionCategory="MAIN_MENU"/>

</y>
----

And add the following to the `initControllerActions()` method of your controller class:

[source,java]
----
ActionNode.builder().
        icon(FontImage.MATERIAL_ALARM).
        label("Notifications").
        addToController(this, StartPage.MAIN_MENU, evt -> {
            System.out.println("Notifications was clicked");
        });

ActionNode.builder().
        icon(FontImage.MATERIAL_PLAYLIST_PLAY).
        label("Playlist").
        addToController(this, StartPage.MAIN_MENU, evt -> {
            System.out.println("Playlist was clicked");
        });

ActionNode.builder().
        icon(FontImage.MATERIAL_CONTENT_COPY).
        label("Copy").
        addToController(this, StartPage.MAIN_MENU, evt -> {
            System.out.println("Copy was clicked");
        });

----

If all goes well, the simulator should reload to resemble the following screenshot:

image::images/buttons-tag.png[]

==== Buttons Layout

The `<buttons>` tag laid out all of the buttons in its specific action category.  Currently they are all laid out on a single line.  The default layout manager for the "Buttons" component is `FlowLayout`, which means that it will lay out actions horizontally from left to right (or right to left for RTL locales), and wrap to the next line when it runs out of space.  It gives you quite a bit of flexibility for how the buttons are arranged and rendered, though.  You can set the layout of `Buttons` to any layout manager that doesn't require a layout constraint.  E.g. _BoxLayout_, _GridLayout_, and _FlowLayout_.

E.g. We can change the layout to _BoxLayout.Y_ by setting the `layout=BoxLayout.y()` attribute:

[source,xml]
----
<buttons layout="BoxLayout.y()" actionCategory="MAIN_MENU"/>
----

image::images/buttons-boxlayout-y.png[]

Or GridLayout using `layout="new GridLayout(2)"`:


[source,xml]
----
<buttons layout="new GridLayout(2,2)" actionCategory="MAIN_MENU"/>
----

image::images/grid-layout-buttons.png[]

==== Action Styles

Actions may include many preferences about how they should be rendered.  The view is not obligated to abide by these preferences, but it usually at least considers them.  We've already seen how actions can specify their preferred icons, labels, and badges, but there are several other properties available as well.  One simple, but useful property is the _action style_ which indicates whether the action should be rendered with both its icon and text, only its icon, or only its text.  This is often overridden by the view based on the context.  E.g. The view may include a menu of actions, and it only wants to display the action icons.

The `<buttons>` tag has an action template that defines "fallback" properties for its actions.  These can be set using the `actionTemplate.*` attributes.  For example, try adding the `actionTemplate.actionStyle` attribute to your `<buttons>` tag.  You should notice that the editor gives you a drop-down list of options for the value of this attribute as shown below:

image::images/action-style-dropdown.png[]

Try selecting different values for this attribute and save the file after each change to see the result in the simulator.  You should see something similar to the following:

.IconBottom
image::images/action-style-icon-bottom.png[]

.IconTop
image::images/action-style-icon-top.png[]

.IconLeft
image::images/action-style-icon-left.png[]

.IconRight
image::images/action-style-icon-right.png[]

.IconOnly
image::images/action-style-icon-only.png[]

You can also specify UIIDs for the actions to customize things like font, color, borders, padding, etc...  To learn more about the various options available, see the Actions chapter of the manual.  (TODO: Create actions section of manual).

==== Overflow Menus

In some cases, your view may only have room for one or two buttons in the space provided, but you want to be able to support more actions than that.  You can use the _limit_ attribute to specify the maximum number of buttons to render.  If the number of actions in the action category is greater than this limit, it will automatically add an overflow menu for the remainder of the actions.

Try adding `limit=1` to the `<buttons>` tag and see what happens:

[source,xml]
----
<buttons
        layout="new GridLayout(2,2)"
        actionCategory="MAIN_MENU"
        actionTemplate.actionStyle="IconOnly"
        limit="1"
/>
----

When the simulator reloads you will see only a "More" button where the menu items once were:

image::images/buttons-more-button.png[]

If you press this button, you will be presented with an Action Sheet with the actions.

image::images/buttons-action-sheet.png[]

If you change the limit to "2", it will show the first action, _Notifications_, in the buttons, and then it will show the remaining two actions when the user presses the "More" button.

image::images/buttons-limit-2.png[]

=== Form Navigation

It's time to grow beyond our single-form playpen, and step into the world of multi-form apps.  Let's create another view in the same folder as _StartPage.xml_.  We'll name this _AboutPage.xml_.  If you're using IntelliJ, like me, you can create this file by right clicking the "myapp" directory in the project inspector, and select _New_ > _File_ as shown here:

image::images/intellij-new-view-xml-file.png[]

Then enter "AboutPage.xml" in the dialog:

image::images/about-page-xml-new-file-prompt.png[]

And press _Enter_

Add the following placeholder contents to the newly created _AboutPage.xml_ file:

[source,xml]
----
<?xml version="1.0"?>
<y>
    <title>About Us</title>
    <label>Under construction</label>
</y>
----

Finally, let's add a button to our original view, _StartPage.xml_ as follows:

[source,xml]
----
<button rad-href="#AboutPage">About Us</button>
----

When the simulator reloads, you should now see this button:

image::images/start-page-about-us-button.png[]

Click on this button, and it should take you to the "About Us" view we just created.

image::images/about-us-page.png[]

Notice that the _About Us_ form includes a _Back_ button that returns you to the _Start Page_.  This is just one of the nice features that you get for free by using CodeRAD.  There is a lot of power packed into the `rad-href` attribute. In this case we specified that we wanted to link to the _AboutPage_ view using the "#AboutPage" URL, it enables other URL types as well.  To learn more about the _rad-href_ attribute, see (TODO section of manual on rad-href).

=== Models

So far we've been working only with the _V_ and _C_ portions of _MVC_.  In this section, I introduce the final pillar in the trinity: _the Model_.  Model objects store the data of the application.  In CodeRAD, _model_ objects implement the _com.codename1.rad.models.Entity_ interface.  We're going to skip the conceptual discussion of _Models_ in this tutorial, and dive directly into an example so you can see how they work.  After we've played with some models, we'll circle back and discuss the theories and concepts in greater depth.

Most apps need a model to encapsulate the currently logged-in user.  Let's create model named _UserProfile_ for this purpose.

Create a new package named "com.example.myapp.models".  In IntelliJ, you can achieve this by right clicking on the _com.example.myapp_ node in the project inspector (inside the _src/main/java_ directory of the _common_ module), and select _New_ > _Package_, as shown here:

image::images/intellij-new-package.png[]

Then enter "models" for the package name in the dialog:

image::images/intellij-new-package-models.png[]

Now create a new Java interface inside this package named "UserProfile".


[source,java]
----
package com.example.myapp.models;

import com.codename1.rad.annotations.RAD;
import com.codename1.rad.models.Entity;
import com.codename1.rad.models.Tag;
import com.codename1.rad.schemas.Person;

@RAD <1>
public interface UserProfile extends Entity {

    /*
     * Declare the tags that we will use in our model. <2>
     */
    public static final Tag name = Person.name;
    public static final Tag photoUrl = Person.thumbnailUrl;
    public static final Tag email = Person.email;

    @RAD(tag="name") <3>
    String getName();
    void setName(String name);

    @RAD(tag="photoUrl")
    String getPhotoUrl();
    void setPhotoUrl(String url);

    @RAD(tag="email")
    String getEmail();
    void setEmail(String email);
}
----
<1> The `@RAD` annotation before the interface definition activates the CodeRAD annotation processor, which will generate a concrete implementation of this interface (named _UserProfileImpl) and a _wrapper_ class this interface (named _UserProfileWrapper_).  More _wrapper classes_ shortly.
<2> We declare and import the tags that we intend to use in our model.  Tags enable us to create views that are loosely coupled to a model.  Since our _UserProfile_ represents a person, we will tag many of the properties with tags from the _Person_ schema.
<3> The `@RAD` annotation before the `getName()` method directs the annotation processor to generate a _property_ named "name".  The `tag="name"` attribute means that this property will accessible via the _name_ tag. This references the `public static final Tag name` field that we defined at the beginning of the interface definition.  More on tags shortly.

Next, let's create a view that allows us to view and edit a _UserProfile_.

In the same directory as the _StartPage.xml_ file, create a new file named _UserProfilePage.xml_ with the following contents:

[source,xml]
----
<?xml version="1.0" ?>

<y rad-model="UserProfile" xsi:noNamespaceSchemaLocation="UserProfilePage.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <import>
        import com.example.myapp.models.UserProfile;
    </import>
    <title>My Profile</title>
    <label>Name:</label>
    <radLabel tag="Person.name"/>
    <label>Email:</label>
    <radLabel tag="Person.email" />
</y>
----

This view looks very similar to the _StartPage_ and _AboutPage_ views we created before, but it introduces a couple of new elements:

`rad-model="UserProfile"`::
This attribute, added to the root element of the XML document specifies that this view's _model_ will a _UserProfile_.
+
IMPORTANT: Remember to import `UserProfile` class in the `<import>` tag, or the view will fail to compile because it won't know where to find the _UserProfile_ class.

`<radLabel tag="Person.name"/>`::
The `<radLabel>` tag is a wrapper around a `Label` that supports binding to a model property.  In this case the `tag=Person.name` attribute indicates that this label should be bound to the property of the model with the `Person.name` tag.  Recall that the _name_ property of the _UserProfile_ included the `@RAD(tag="name")` annotation, which effectively "tagged" the property with the "name" tag.
+
TIP: In this example I chose to reference the `Person.name` tag from the _Person_ schema, but since our _UserProfile_ class referenced this tag in its `name` static field, we could have equivalently referenced `tag="UserProfile.name"` here.

Before we fire up the simulator, we also need to add a _link_ to our new form so we can test it out.  Add a button to the _StartPage_ view that links to our _UserProfilePage_:

[source,xml]
----
<button rad-href="#UserProfilePage">User Profile</button>
----

Now fire up the simulator and click on the _User Profile_ button we added.  YOu should see something like the this:

image::images/user-profile-page.png[]

This is a little boring right now because we haven't specified a _UserProfile_ object to use as the model for this view, so it just creates a new (empty) instance of _UserProfile_ and uses that.  Let's remedy that by instantiating a _UserProfile_ in our controller, and then use _that_ profile as the view for our profile.

Open the RADApp class and implement the following method:

[source,java]
----
@Override
protected void onStartController() {
    super.onStartController();

    UserProfile profile = new UserProfileImpl();
    profile.setName("Jerry");
    profile.setEmail("jerry@example.com");
    addLookup(UserProfile.class, profile);
}
----

TIP: The `onStartController()` method is the preferred place to add initialization code for your controller.  Placing initialization here rather than in the constructor ensures the controller is "ready" to be initailized.

Most of this snippet should be straight forward.  I'll comment on two aspects here:

1. We use the `UserProfileImpl` class, which is the default concrete implementation of our _UserProfile_ entity that was generated for us by the annotation processor.
2. The `addLookup()` method adds a _lookup_ to our controller so that the profile we just created can be accessed throughout the app by calling the `Controller.lookup()` method, passing it `UserProfile.class` as a parameter.  Lookups are used throughout CodeRAD as they are a powerful way to "share" objects between different parts of your app while still being loosely coupled.

Now, we will make a couple of changes to the _StartPage_ view to inject this profile into the _UserProfile_ view.

First, we need to add _UserProfile_ to the _imports_ of _StartPage_.

[source,xml]
----
<import>
import com.example.myapp.models.UserProfile;
</import>
----

Next, add the following tag somewhere in the root of the _StartPage.xml_ file:

[source,xml]
----
<var name="profile" lookup="UserProfile"/>
----

This declares a "variable" named _profile_ in our view with the value of the _UserProfile_ lookup.  This is roughly equivalent to the java:

[source,java]
----
UserProfile profile = controller.lookup(UserProfile.class);
----


Finally, change the `<button>` tag in the _StartPage_ that we used to link to the _UserProfile_ page to indicate that it should use the _profile_ as the model for the _UserProfilePage_:

[source,xml]
----
<button rad-href="#UserProfilePage{profile}">User Profile</button>
----

The active ingredient we added here was the "{profile}" suffix to the URL.  This references the `<var name="profile"...>` tag we added earlier.

When we're done, the `StartPage.xml` contents will look like:

[source,xml]
----
<?xml version="1.0"?>
<y scrollableY="true" xsi:noNamespaceSchemaLocation="StartPage.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <!-- We need to import the UserProfile class since we use it
        in various places of this view. -->
    <import>
        import com.example.myapp.models.UserProfile;
    </import>

    <!-- Reference to the UserProfile looked up
        from the Controller.  This lookup is registered
        in the onStartController() method of the MyRADApp class. -->
    <var name="profile" lookup="UserProfile"/>
    <define-category name="HELLO_CLICKED"/>

    <define-category name="MAIN_MENU" />
    <title>Hi World</title>
    <button text="Hello World">
        <bind-action category="HELLO_CLICKED"/>
    </button>
    <buttons
            layout="new GridLayout(2,2)"
            actionCategory="MAIN_MENU"
            actionTemplate.actionStyle="IconOnly"
            limit="2"
    />
    <button rad-href="#AboutPage">About Us</button>

    <!-- This button links to the UserProfilePage
         The {profile} suffix means that the UserProfilePage
         should use the "profile" reference created by
         the <var name="profile"...> tag above.
     -->
    <button rad-href="#UserProfilePage{profile}">User Profile</button>

</y>
----

Now, we we click on the _User Profile_ button, it should display the details of the profile we created:

image::images/bound-user-profile-page.png[]

.The "Poor Man's" Hot Reload
****
CodeRAD has experimental support for full, proper, _Hot reload_ but it currently requires some additional setup that is beyond the scope of this _getting started_ tutorial.

Throughout this tutorial, we have been using a sort of _pseudo_ hot-reload mechanism whereby the simulator reloads your app entirely when it detects changes to your app's source code. This is actually quite efficient if you are working on the _first_ form of your app.  But if you are working on a form that you need to navigate to, it can become tedious, since with each change to your source, your app will restart, and you'll need to navigate to the form of interest _again_.

In order to simplify our lives, it can be helpful to _temporarily_ modify the application controller to show the form that you are currently "working" on.  In our case, we will be working on the _UserProfilePage_ for the next few sections, so I will add the following to the `actionPerformed()` method of the `MyRADApp` class:

[source,java]
----
if (true) {
    new UserProfilePageController(this, lookup(UserProfile.class)).show();
    return;
}
----

The full `actionPerformed()` method would, then, look something like :

[source,java]
----
public void actionPerformed(ControllerEvent evt) {

    with(evt, StartEvent.class, startEvent -> {
        if (true) {
            new UserProfilePageController(this, lookup(UserProfile.class)).show();
            return;
        }
        startEvent.setShowingForm(true);
        new StartPageController(this).show();
    });
    super.actionPerformed(evt);
}
----

There are a couple of things worth commenting on here:

1. The `UserProfilePageController` class is a _FormController_ subclass that is generated by the annotation processor.  It is a default implementation of a controller for displaying the `UserProfilePage` view.
2. The second parameter of the `UserProfilePageController` constructor takes the _view model_ for the `UserProfilePage` view as a parameter.  In this case we are using the `UserProfile` object that we added as a lookup previously in the `onStartController()` method.

This little snippet will cause the app to _always_ show the _UserProfilePage_ when it starts.  We'll remove this once we have finished "working on" the _UserProfilePage_ view.

****

=== Fun with Bindings

TIP: Throughout this guide I use the terms _model_ and _entity_ interchangeably because CodeRAD names it's _model_ class `Entity`.

CodeRAD models are designed to allow for easy binding to other models and to user interface components.  We've already seen how the `<radLabel>` tag can be bound to a model property using the `tag` attribute, but you aren't limited to static labels.  There are `radXXX` components for many of the fundamental Codename One components.  E.g. `<radTextField>`, `<radTextArea>`, `<radSpanLabel>`, and many more.  Later on, you'll also learn how to build your own _binding_ components, but for now, let's have a little bit of fun with the standard ones.

To demonstrate that you can bind more than one component to the same property, let's add a `<radTextField>` that binds to the _email_ property just below the existing `<radLabel>`.

[source,xml]
----
<radTextField tag="Person.email"/>
----

image::images/radlabel-bound-to-same-property-as-radtextfield.png[]

You'll notice that as you type in the _email_ text field, the value of the _email_ label also changes.  This is because they are bound to the same property of the same model.

We can even go a step further.  It is possible to bind _any_ any property to the result of an arbitrary Java expression so that the property will be updated whenever the model is changed.

As an example, let's add a button that is enabled _only_ when the model's _email_ property is non-empty:

[source,xml]
----
<button bind-enabled="java:!getEntity().isEmpty(UserProfile.email)">Save</button>
----

TIP: The _bind-*_ attributes, by default expect their values to be references to a tag (e.g. `UserProfile.email`), but you can alternatively provide a Java expression prefixed with `java:`.

You will notice, now, that if you delete the content of the _email_ text field on the form, the _Save_ button becomes disabled.  If you start typing again, the button will become enabled again.


























