package com.codename1.rad.annotations.processors;

import com.codename1.rad.annotations.Autogenerated;
import com.codename1.rad.annotations.RAD;
import com.google.auto.service.AutoService;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import java.util.Set;

import static com.codename1.rad.annotations.processors.ProcessorConstants.*;
import static com.codename1.rad.annotations.processors.ProcessorConstants.ENTITY_TYPE;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;
import java.io.IOException;
import java.io.PrintWriter;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.tools.JavaFileObject;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.MethodSpec;

import java.io.ByteArrayInputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.PackageElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.TypeKind;
import javax.lang.model.util.Elements;
import javax.tools.Diagnostic.Kind;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathFactory;
import org.apache.commons.text.StringEscapeUtils;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

@SupportedAnnotationTypes(RAD_ANNOTATION_TYPE)
@SupportedSourceVersion(SourceVersion.RELEASE_8)
@AutoService(Processor.class)
public class EntityProcessor extends AbstractProcessor {



    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        boolean out = processSchemas(annotations, roundEnv);
        out = processEntities(annotations, roundEnv) || out;
        out = processFragments(annotations, roundEnv) || out;
        out = processViews(annotations, roundEnv) || out;
        
        
        return out;
    }
    
    public boolean processFragments(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        Set<? extends Element> annotatedElements = (Set<? extends TypeElement>)roundEnv.getElementsAnnotatedWith(RAD.class);
        TypeElement entityViewType = processingEnv.getElementUtils().getTypeElement("com.codename1.rad.ui.EntityViewFragment");
        for (Element el : annotatedElements) {
            if (!(el instanceof TypeElement)) continue;
            TypeElement typeEl = (TypeElement)el;
            if (!isA(typeEl, "com.codename1.rad.ui.EntityViewFragment")) {
                continue;
            }
            
            processFragment(typeEl);
            
        }
        return true;
        
    }
    
    public boolean processViews(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        Set<? extends Element> annotatedElements = (Set<? extends TypeElement>)roundEnv.getElementsAnnotatedWith(RAD.class);
        TypeElement entityViewType = processingEnv.getElementUtils().getTypeElement("com.codename1.rad.ui.EntityView");
        for (Element el : annotatedElements) {
            if (!(el instanceof TypeElement)) continue;
            TypeElement typeEl = (TypeElement)el;
            if (!isA(typeEl, "com.codename1.rad.ui.EntityView")) {
                continue;
            }
            
            processView(typeEl);
            
        }
        return true;
    }
    
    private void processView(TypeElement typeEl) {
        
    }
    
    private boolean isA(TypeMirror mirror, String fqn) {
        return isA(processingEnv.getElementUtils().getTypeElement(mirror.toString()), fqn);
    }
    
                
    private void processFragment(TypeElement typeEl) {
        final Set<Element> dependentElements = new HashSet<>();
        dependentElements.add(typeEl);
        try {
            String xmlString = null;
            for (Element member : processingEnv.getElementUtils().getAllMembers(typeEl)) {
                if (member.getKind() == ElementKind.FIELD && member.getSimpleName().contentEquals("FRAGMENT_XML")) {
                    if (!(member instanceof VariableElement)) {
                        continue;
                    }
                    VariableElement varEl = (VariableElement)member;
                    xmlString = (String)varEl.getConstantValue();
                    break;
                    
                }
            }
            
            if (xmlString == null) {
                processingEnv.getMessager().printMessage(Kind.ERROR, "Cannot find member FRAGMENT_XML in fragment class "+typeEl.getQualifiedName()+".", typeEl);
                return;
            }
            
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            org.w3c.dom.Document doc = builder.parse(new ByteArrayInputStream(xmlString.getBytes("utf-8")), "utf-8");
            
            
            /**
             * Encapsulates a `<rad:namespace>` tag which is used to define where to 
             * find Tags, Builders, and Categories.
             */
            class Namespace {
                /**
                 * A package that is scoured for tags, categories and builders.  
                 */
                String nsPackage;
                
                /**
                 * A class that is checked for tags, categories, and builders.
                 */
                String nsClass;
                
                /**
                 * Looks at static fields in class to find Tag with given name.
                 */
                String findTagInClass(TypeElement typeEl, String name) {
                     List<Element> fields = typeEl.getEnclosedElements().stream()
                            .filter(element -> element.getKind() == ElementKind.FIELD).collect(Collectors.toList());


                    for (Element el : fields) {
                        if (el.getModifiers().contains(Modifier.STATIC)) {
                            continue;
                        }
                        if (!el.getSimpleName().contentEquals(name)) {
                            continue;
                        }
                        TypeMirror fieldType = el.asType();
                        if (fieldType.toString().equals("com.codename1.rad.models.Tag")) {
                            return typeEl.toString() + "." + el.getSimpleName().toString();
                        }

                    }
                    return null;
                    
                }
                
                /**
                 * Looks at class to find static Category fields with given name.
                 */
                String findCategoryInClass(TypeElement typeEl, String name) {
                     List<Element> fields = typeEl.getEnclosedElements().stream()
                            .filter(element -> element.getKind() == ElementKind.FIELD).collect(Collectors.toList());


                    for (Element el : fields) {
                        if (el.getModifiers().contains(Modifier.STATIC)) {
                            continue;
                        }
                        if (!el.getSimpleName().contentEquals(name)) {
                            continue;
                        }
                        TypeMirror fieldType = el.asType();
                        if (fieldType.toString().equals("com.codename1.rad.nodes.ActionNode.Category")) {
                            return typeEl.toString() + "." + el.getSimpleName().toString();
                        }

                    }
                    return null;
                    
                }
                
                /**
                 * Looks at class to see if it is a builder class with the given tag annotation.  Also
                 * looks in inner classes.
                 */
                String findBuilderInClass(TypeElement typeEl, String tagName) {
                    
                    if (typeEl == null) return null;
                    RAD annotation = typeEl.getAnnotation(RAD.class);
                    
                    if (annotation != null && isA(typeEl, "com.codename1.rad.ui.ComponentBuilder")) {
                        
                        for (String annoTag : annotation.tag()) {
                            if (tagName.equals(annoTag)) {
                                return typeEl.getQualifiedName().toString();
                            }
                        }
                    }

                    List<Element> classes =  typeEl.getEnclosedElements().stream()
                        .filter(element -> element.getKind() == ElementKind.CLASS || element.getKind() == ElementKind.INTERFACE).collect(Collectors.toList());
                    for (Element childClass : classes) {
                        String match = findBuilderInClass((TypeElement)childClass, tagName);
                        if (match != null) {
                            return match;
                        }
                    }
                    return null;
                        
                        
                }
                
                /**
                 * Finds a builder in this namespace annotated with the given tag.  Annotation
                 * is `@RAD(tag="sometag")`
                 */
                String findBuilder(String tagName) {
                    if (nsClass != null) {
                        TypeElement typeEl = processingEnv.getElementUtils().getTypeElement(nsClass);
                        return findBuilderInClass(typeEl, tagName);
                        
                        
                        
                    }
                    if (nsPackage != null) {
                        PackageElement pkgEl = processingEnv.getElementUtils().getPackageElement(nsPackage);
                        List<Element> classes =  pkgEl.getEnclosedElements().stream()
                                .filter(element -> element.getKind() == ElementKind.CLASS || element.getKind() == ElementKind.INTERFACE).collect(Collectors.toList());
                        for (Element clsEl : classes) {
                            String match = findBuilderInClass((TypeElement)clsEl, tagName);
                            if (match != null) {
                                return match;
                            }
                        }
                        
                    }
                    
                    return null;
                }
                
                
                        
                /**
                 * Finds a tag with the given name in the namespace.
                 */
                String findTag(String name) {
                    if (nsClass != null) {
                        TypeElement typeEl = processingEnv.getElementUtils().getTypeElement(nsClass);
                        if (typeEl == null) return null;
                        return findTagInClass(typeEl, name);
                        
                        
                    }
                    if (nsPackage != null) {
                        PackageElement pkgEl = processingEnv.getElementUtils().getPackageElement(nsPackage);
                        List<Element> classes =  pkgEl.getEnclosedElements().stream()
                                .filter(element -> element.getKind() == ElementKind.CLASS || element.getKind() == ElementKind.INTERFACE).collect(Collectors.toList());
                        for (Element clsEl : classes) {
                            String match = findTagInClass((TypeElement)clsEl, name);
                            if (match != null) {
                                return match;
                            }
                        }
                        
                    }
                    
                    return null;
                }
                
                /**
                 * Finds a category with the given name in the namespace.
                 */
                String findCategory(String name) {
                     if (nsClass != null) {
                        TypeElement typeEl = processingEnv.getElementUtils().getTypeElement(nsClass);
                        if (typeEl == null) return null;
                        return findCategoryInClass(typeEl, name);
                        
                        
                    }
                    if (nsPackage != null) {
                        PackageElement pkgEl = processingEnv.getElementUtils().getPackageElement(nsPackage);
                        List<Element> classes =  pkgEl.getEnclosedElements().stream()
                                .filter(element -> element.getKind() == ElementKind.CLASS || element.getKind() == ElementKind.INTERFACE).collect(Collectors.toList());
                        for (Element clsEl : classes) {
                            String match = findCategoryInClass((TypeElement)clsEl, name);
                            if (match != null) {
                                return match;
                            }
                        }
                        
                    }
                    
                    return null;
                }
            }
            
            // Load all of the namespaces listed in <namespace> tags.
            final List<Namespace> namespaces = new ArrayList<Namespace>();
            
            {
                NodeList nsList = doc.getElementsByTagNameNS("*'", "namespace");
                int len = nsList.getLength();
                for (int i = 0; i<len; i++) {
                    org.w3c.dom.Element el = (org.w3c.dom.Element)nsList.item(i);
                    String pkg = (String)el.getAttribute("package");
                    Namespace ns = new Namespace();
                    ns.nsPackage = (String)el.getAttribute("package");
                    ns.nsClass = (String)el.getAttribute("class");
                    namespaces.add(ns);


                }
            }

            Namespace buildersNs = new Namespace();
            buildersNs.nsPackage = "com.codename1."

            
            
            
            final StringBuilder sb = new StringBuilder();
            sb.append("    @Override\n");
            sb.append("    public Component createComponent() { return createComponent0(); }\n");
            
            class Generator {
                
                
                String findCategory(String categoryName) {
                    for (Namespace ns : namespaces) {
                        String match = ns.findCategory(categoryName);
                        if (match != null) {
                            return match;
                        }
                    }
                    return null;
                }
                String getBuilderClass(String tagName) {
                    for (Namespace ns : namespaces) {
                        String match = ns.findBuilder(tagName);
                        if (match != null) {
                            return match;
                        }
                    }
                    return null;
                }
                
                String findTag(String tagName) {
                    for (Namespace ns : namespaces) {
                        String match = ns.findTag(tagName);
                        if (match != null) {
                            return match;
                        }
                    }
                    return null;
                }
                
                void generate(org.w3c.dom.Element e) {
                    String elementId = e.getAttribute("elementId");
                    if (elementId != null) {
                        sb.append("    private Component createComponent").append(elementId).append("() {\n");
                        String builderClass = getBuilderClass(e.getTagName());
                        if (builderClass == null) {
                            processingEnv.getMessager().printMessage(Kind.ERROR, "Cannot find builder for tag "+e.getTagName(), typeEl);
                            return;
                        }
                        NamedNodeMap attributes = e.getAttributes();
                        TypeElement builderTypeEl = processingEnv.getElementUtils().getTypeElement(builderClass);
                        dependentElements.add(builderTypeEl);
                        List<Element> builderMethods = processingEnv.getElementUtils().getAllMembers(builderTypeEl).stream()
                                .filter(m -> m.getKind() == ElementKind.METHOD).collect(Collectors.toList());
                        Optional<ExecutableElement> getComponentMethodEl = (Optional<ExecutableElement>)processingEnv.getElementUtils().getAllMembers(builderTypeEl).stream()
                                .filter(m -> m.getKind() == ElementKind.METHOD && m.getSimpleName().contentEquals("getComponent")).findFirst();
                        
                        if( !getComponentMethodEl.isPresent()) {
                            processingEnv.getMessager().printMessage(Kind.ERROR, "Cannot find getComponent() method in builder "+typeEl, typeEl);
                        }
                        String componentType = getComponentMethodEl.get().getReturnType().toString();
                        Map<String,Element> componentMethodMap = new HashMap<>();
                        TypeElement componentTypeEl = processingEnv.getElementUtils().getTypeElement(componentType);
                        List<Element> componentMethods = processingEnv.getElementUtils().getAllMembers(componentTypeEl).stream()
                                .filter(m -> m.getKind() == ElementKind.METHOD).collect(Collectors.toList());
                        for (Element m : componentMethods) {
                            if (!(m instanceof ExecutableElement)) {
                                continue;
                            }
                            ExecutableElement exM = (ExecutableElement)m;
                            if (exM.getParameters().size() != 1) {
                                continue;
                            }
                            if (!exM.getSimpleName().toString().startsWith("set")) {
                                componentMethodMap.put(m.getSimpleName().toString().toLowerCase(), m);
                            }
                        }
                        
                        
                        Map<String,Element> builderMethodMap = new HashMap<>();
                        for (Element m : builderMethods) {
                            if (!(m instanceof ExecutableElement)) {
                                continue;
                            }
                            ExecutableElement exM = (ExecutableElement)m;
                            if (exM.getParameters().size() != 1) {
                                continue;
                            }
                            builderMethodMap.put(m.getSimpleName().toString().toLowerCase(), m);
                        }
                        
                        sb.append("        ").append(builderClass).append(" builder = new ").append(builderClass).append("(getEntityView());\n");
                        int numAtts = attributes.getLength();
                        for (int i=0; i<numAtts; i++) {
                            org.w3c.dom.Attr attribute = (org.w3c.dom.Attr)attributes.item(i);
                            ExecutableElement builderMethod = (ExecutableElement)builderMethodMap.get(attribute.getName().toLowerCase());
                            
                            boolean useComponentMethod=false;
                            if (builderMethod == null) {
                                builderMethod = (ExecutableElement)componentMethodMap.get(attribute.getName().toLowerCase());
                                useComponentMethod = builderMethod != null;
                                
                            }
                            if (builderMethod == null) {
                                processingEnv.getMessager().printMessage(Kind.ERROR, "Cannot find method in builder appropriate to handle attribute "+attribute.getName()+" while processing XML element "+e, typeEl);
                                return;
                            }
                            
                            String getComponent = "";
                            if (useComponentMethod) getComponent = "getComponent().";
                            
                            VariableElement param = ((List<VariableElement>)builderMethod.getParameters()).get(0);
                            String methodName = builderMethod.getSimpleName().toString();
                            String paramType = param.asType().toString();
                            if (isPrimitive(param.asType())) {
                                sb.append("        builder.").append(getComponent).append(methodName).append("(").append(attribute.getValue()).append(");\n");
                            } else if (paramType.equals("java.lang.String")) {
                                sb.append("        builder.").append(getComponent).append(methodName).append("(\"").append(StringEscapeUtils.escapeJava(attribute.getValue())).append("\");\n");
                            } else if (paramType.equals("com.codename1.rad.models.Tag")) {
                                sb.append("        builder.").append(getComponent).append(methodName).append("(").append(findTag(attribute.getValue())).append(");\n");
                            } else if (paramType.equals("com.codename1.rad.models.Tags")) {
                                sb.append("        builder.").append(getComponent).append(methodName).append("(new Tags(");
                                StringTokenizer strtok = new StringTokenizer(attribute.getValue(), " ,;");
                                boolean first = true;
                                while (strtok.hasMoreTokens()) {
                                    if (first) {
                                        first = false;
                                    } else {
                                        sb.append(", ");
                                    }
                                    sb.append(findTag(strtok.nextToken()));
                                    
                                }
                                sb.append("));\n");
                                
                            } else if (paramType.equals("com.codename1.rad.models.Tag[]")) {
                                sb.append("        builder.").append(getComponent).append(methodName).append("(new Tag[]{");
                                StringTokenizer strtok = new StringTokenizer(attribute.getValue(), " ,;");
                                boolean first = true;
                                while (strtok.hasMoreTokens()) {
                                    if (first) {
                                        first = false;
                                    } else {
                                        sb.append(", ");
                                    }
                                    sb.append(findTag(strtok.nextToken()));
                                    
                                }
                                sb.append("});\n");
                                
                            } else if (paramType.equals("com.codename1.rad.nodes.ActionNode.Category")) {
                                sb.append("        builder.").append(getComponent).append(methodName).append("(").append(findCategory(attribute.getValue())).append(");\n");
                            } else if (paramType.equals("com.codename1.rad.nodes.ActionNode.Category[]")) {
                                sb.append("        builder.").append(getComponent).append(methodName).append("(new ActionNode.Category[]{");
                                StringTokenizer strtok = new StringTokenizer(attribute.getValue(), " ,;");
                                boolean first = true;
                                while (strtok.hasMoreTokens()) {
                                    if (first) {
                                        first = false;
                                    } else {
                                        sb.append(", ");
                                    }
                                    sb.append(findCategory(strtok.nextToken()));
                                    
                                }
                                sb.append("});\n");
                            } else if (param.asType().getKind() == TypeKind.ARRAY) {
                                if (paramType.equals("int[]") || paramType.equals("float[]") || paramType.equals("double[]") || paramType.equals("short[]") || paramType.equals("long[]") ||
                                        paramType.equals("byte[]") || paramType.equals("char[]") || paramType.equals("boolean[]")) {
                                    sb.append("        builder.").append(getComponent).append(methodName).append("(new").append(paramType).append("{");
                                    StringTokenizer strtok = new StringTokenizer(attribute.getValue(), " ,;");
                                    boolean first = true;
                                    while (strtok.hasMoreTokens()) {
                                        if (first) {
                                            first = false;
                                        } else {
                                            sb.append(", ");
                                        }
                                        sb.append(strtok.nextToken());

                                    }
                                    sb.append("});\n");
                                } else if (paramType.equals("java.lang.String[]")) {
                                    sb.append("        builder.").append(getComponent).append(methodName).append("(new").append(paramType).append("{");
                                    StringTokenizer strtok = new StringTokenizer(attribute.getValue(), " ,;");
                                    boolean first = true;
                                    while (strtok.hasMoreTokens()) {
                                        if (first) {
                                            first = false;
                                        } else {
                                            sb.append(", ");
                                        }
                                        sb.append("\"").append(StringEscapeUtils.escapeJava(strtok.nextToken())).append("\"");

                                    }
                                    sb.append("});\n");
                                }
                            } else {
                                processingEnv.getMessager().printMessage(Kind.WARNING, "Builder class "+builderClass+" does not have a method corresponding to the parameter "+attribute.getValue()+".  It does have "+builderMethod+", but the parameter type "+paramType+" is not supported for XML builders.  Only String, primitives, boxed, primitives, Tag, Category, and arrayes thereof are supported.", builderTypeEl);
                            }
                            
                                    
                            
                        }
                        
                        
                        Optional<Element> buildMethod = (Optional<Element>) processingEnv.getElementUtils().getAllMembers(builderTypeEl).stream()
                                .filter(mem -> mem.getSimpleName().contentEquals("build")).findAny();
                        if (!buildMethod.isPresent()) {
                            processingEnv.getMessager().printMessage(Kind.ERROR, "Builder class "+builder+" has no build() method.", builderTypeEl);
                            return;
                        }

                        ExecutableElement buildMethodEl = (ExecutableElement)buildMethod.get();
                        
                        
                        
                        
                        NodeList children = e.getChildNodes();
                        int len = children.getLength();
                        for (int i=0; i<len; i++) {
                            org.w3c.dom.Node child = (Node)children.item(i);
                            if (!(child instanceof org.w3c.dom.Element)) {
                                continue;
                            }
                            org.w3c.dom.Element childEl = (org.w3c.dom.Element)child;
                            String childElementId = childEl.getAttribute("elementId");
                            String childBuilder = getBuilderClass(childElementId);
                            TypeElement childBuilderType = processingEnv.getElementUtils().getTypeElement(childBuilder);
                            dependentElements.add(childBuilderType);
                            java.util.Optional<Element> childBuildMethod = (Optional<Element>) processingEnv.getElementUtils().getAllMembers(childBuilderType).stream()
                                    .filter(mem -> mem.getSimpleName().contentEquals("build")).findAny();
                            if (!childBuildMethod.isPresent()) {
                                processingEnv.getMessager().printMessage(Kind.ERROR, "Builder class "+childBuilder+" has no build() method.", childBuilderType);
                                continue;
                            }
                            
                            ExecutableElement childBuildMethodEl = (ExecutableElement)childBuildMethod.get();
                            Optional<Element> addMethod = (Optional<Element>)processingEnv.getElementUtils().getAllMembers(builderTypeEl).stream()
                                    .filter(m -> m.getSimpleName().toString().startsWith("add"))
                                    .filter(m -> m.getKind() == ElementKind.METHOD)
                                    .filter(m -> ((ExecutableElement)m).getParameters().size() == 1)
                                    .filter(m -> isA(childBuildMethodEl.getReturnType(), ((ExecutableElement)m).getParameters().get(0).asType().toString()))
                                    .findFirst();
                            
                            if (!addMethod.isPresent()) {
                                // No appropriate add method in the builder.
                                // If the component is a container, then we can probably just the regular addComponent() methods.
                                if (processingEnv.getTypeUtils().isAssignable(componentTypeEl.asType(), processingEnv.getElementUtils().getTypeElement("com.codename1.ui.Container").asType())) {
                                    String constraint = childEl.getAttribute("layout-constraint");
                                    if (constraint == null) {
                                        sb.append("        builder.getComponent().addComponent(createComponent").append(childElementId).append("());\n");
                                    } else {
                                        sb.append("        builder.getComponent().addComponent(builder.parseConstraint(\"").append(StringEscapeUtils.escapeJava(constraint)).append("\", createComponent").append(childElementId).append("());\n");
                                    }
                            
                                } else {
                                    processingEnv.getMessager().printMessage(Kind.ERROR, "Builder class "+builderClass+" has no addXXX() method that can take the output of the child builder class "+childBuilder+".  The child builder's build() method returns a "+childBuildMethodEl.getReturnType()+" so in order for it to be an elligible child of "+builderClass+", builderClass must have a method named addXXX(param) with param accepting type "+childBuildMethodEl.getReturnType(), builderTypeEl);
                                    return;
                                }
                            } else {
                                 sb.append("        builder.").append(addMethod.get().getSimpleName()).append("(createComponent").append(childElementId).append("());\n");
                            }
                            
                           
                            
                        }
                        sb.append("        return builder.getComponent();\n");
                        sb.append("    }\n");
                        
                    }
                    
                    NodeList children = e.getChildNodes();
                    int len = children.getLength();
                    for (int i=0; i<len; i++) {
                        org.w3c.dom.Node child = (Node)children.item(i);
                        if (!(child instanceof org.w3c.dom.Element)) {
                            continue;
                        }
                        generate((org.w3c.dom.Element)child);
                    }
                }
            }
            Generator generator = new Generator();
            generator.generate(doc.getDocumentElement());
            
            String methods = sb.toString();
            sb.setLength(0);
            String packageName = "";
            PackageElement packageEl = processingEnv.getElementUtils().getPackageOf(typeEl);
            if (packageEl != null) {
                packageName = packageEl.getQualifiedName().toString();
                sb.append("package ").append(packageEl.getQualifiedName()).append(";\n");
            }
            sb.append("import com.codename1.ui.Component;\n");
            sb.append("import com.codename1.rad.ui.EntityView;\n");
            
            String className = typeEl.getSimpleName().toString();
            if (className.startsWith("Abstract")) {
                className = className.substring("Abstract".length());
            }
            if (!className.endsWith("Fragment")) {
                className = className+"Fragment";
            }
            if (typeEl.getSimpleName().contentEquals(className)) {
                className += "Impl";
            }
            Map<String,String> tagMap = new HashMap<>();
            Map<String,String> categoryMap = new HashMap<>();
            XPath xpath = XPathFactory.newInstance().newXPath();
            
            sb.append("public class ").append(className).append(" extends ").append(typeEl.getQualifiedName().toString()).append(" {\n");
            sb.append("    public ").append(className).append("(EntityView context) {\n");
            sb.append("        super(context);\n");
            sb.append("    }\n");
            sb.append(methods);
            sb.append("}\n");
            
            String fqn = packageName;
            if (fqn.length() > 0) fqn += ".";
            fqn += className;
            JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(fqn, dependentElements.toArray(new Element[dependentElements.size()])); 
            try (java.io.Writer w = sourceFile.openWriter()) {
                w.write(sb.toString());
            }
            
            
            
        } catch (Exception ex) {
            processingEnv.getMessager().printMessage(Kind.ERROR, "Parsing XML fragment "+typeEl.getQualifiedName()+".", typeEl);
            Logger.getLogger(EntityProcessor.class.getName()).log(Level.SEVERE, null, ex);
            return;
        }
    }
    
    private boolean isPrimitive(TypeMirror el) {
        switch (el.getKind()) {
            case BOOLEAN:
            case FLOAT:
            case DOUBLE:
            case INT:
            case LONG:
            case CHAR:
            case SHORT:
            case BYTE:
                return true;
        }
        return false;
    }
    
    public boolean processSchemas(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        

        
        Set<? extends Element> annotatedElements = (Set<? extends TypeElement>)roundEnv.getElementsAnnotatedWith(RAD.class);
        for (Element e : annotatedElements) {
            //createEntityClass(e, roundEnv);
            

        }
        
        return false;
    }
    
    private String getEntityNameFor(TypeElement el) {
        if (el.getKind() == ElementKind.CLASS && el.getSimpleName().toString().startsWith("Abstract")) {
            return el.getSimpleName().toString().substring("Abstract".length());
        } else if (el.getKind() == ElementKind.INTERFACE && el.getSimpleName().toString().startsWith("I")) {
            return el.getSimpleName().toString().substring(1);
        } else if (el.getKind() == ElementKind.INTERFACE) {
            return el.getSimpleName().toString();
        } else {
            throw new IllegalArgumentException("TypeElement is not an entity. Classes must begin with Abstract, and Interface must begin with I");
        }
    }
    
    private PackageElement getPackageElement(Element el) {
        if (el == null) return null;
        if (el.getKind() == ElementKind.PACKAGE) return (PackageElement)el;
        return getPackageElement(el.getEnclosingElement());
    }
    
    
    
    private void validateTag(String tag, Element sourceElement) {
        Element field = findField(tag, sourceElement);
        if (field == null) {
            processingEnv.getMessager().printMessage(Kind.ERROR, "The tag "+tag+" could not be found. Be sure that it is available as a public, protected, or package-private static field in this class/interface or a superclass/interface.", sourceElement);
        }
        
    }
    
    private Element findField(String name, Element source) {
        if (source == null || source.getKind() == ElementKind.PACKAGE) {
            return null;
        }
        if (source instanceof TypeElement) {
            for (Element child : processingEnv.getElementUtils().getAllMembers((TypeElement)source)) {

                if (child.getKind() == ElementKind.FIELD && child.getSimpleName().contentEquals(name)) {
                    return child;
                }
            }
        }
        
        Element parent = source.getEnclosingElement();
        
        if (parent != null) {
            
            return findField(name, parent);
        }
        
        return null;
            
    }
    
    
    
    private class ExecutionPlan {
        private Map<String,EntityPlan> entityPlans = new HashMap<>();
        private RoundEnvironment roundEnv;
        private Set<? extends TypeElement> annotations;
        
        ExecutionPlan(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
            this.annotations = annotations;
            this.roundEnv = roundEnv;
            
            Set<? extends Element> annotatedElements = (Set<? extends TypeElement>)roundEnv.getElementsAnnotatedWith(RAD.class);
            //System.out.println("AnnotatedElements this round : "+annotatedElements);
            Set<EntityPlan> plans = new LinkedHashSet<>();
            TypeElement entityView = processingEnv.getElementUtils().getTypeElement("com.codename1.rad.ui.EntityView");
            TypeElement entityFragment = processingEnv.getElementUtils().getTypeElement("com.codename1.rad.ui.EntityViewFragment");
            TypeElement componentBuilder = processingEnv.getElementUtils().getTypeElement("com.codename1.rad.ui.ComponentBuilder");
            TypeElement component = processingEnv.getElementUtils().getTypeElement("com.codename1.ui.Component");
            for (Element e : annotatedElements) {
                if (e instanceof TypeElement) {
                    TypeElement typeEl = (TypeElement)e;
                    
                    if (processingEnv.getTypeUtils().isAssignable(typeEl.asType(), entityView.asType())) {
                        // If this is an EntityView, then we will process this using the EntityView pathway
                        // Which will try to generate an EntityViewFragment from a template.
                        continue;
                        
                    }
                    if (processingEnv.getTypeUtils().isAssignable(typeEl.asType(), entityFragment.asType())) {
                        // If this is an EntityView, then we will process this using the EntityView pathway
                        // Which will try to generate an EntityViewFragment from a template.
                        continue;
                        
                    }
                    
                    //if (processingEnv.getTypeUtils().isAssignable(typeEl.asType(), processingEnv.getTypeUtils().getDeclaredType(componentBuilder, component.asType()))) {
                    if (isA(typeEl, "com.codename1.rad.ui.ComponentBuilder")) {
                        // If this is an EntityView, then we will process this using the EntityView pathway
                        // Which will try to generate an EntityViewFragment from a template.
                        continue;
                        
                    } else {
                        System.out.println(typeEl+" is not assignablt to "+componentBuilder.asType());
                        System.out.println("Superclass is "+typeEl.getSuperclass());
                        TypeMirror superclass = typeEl.getSuperclass();
                        if (superclass != null) {
                            System.out.println("Superclass Element: "+processingEnv.getTypeUtils().asElement(superclass));
                            if (processingEnv.getTypeUtils().asElement(superclass) != null) {
                                System.out.println("Interfaces: "+((TypeElement)processingEnv.getTypeUtils().asElement(superclass)).getInterfaces());
                            }
                        }
                        
                    }
                    
                    if (!validate(typeEl)) {
                        return;
                    }
                    EntityPlan plan = getEntityPlanFor(typeEl);
                    
                    if (plan == null) {
                        throw new RuntimeException("Problem processing @RAD annotation.  Failed to get plan for element");
                        
                    }
                    plan.toProcess.add(typeEl);
                    plans.add(plan);
                   
                    
                }
            }
            for (EntityPlan plan : plans) {
                plan.executePlan(roundEnv);
            }
        }
        
        
        boolean processEntityView(TypeElement el) {
            
            return true;
        }
        
        boolean validate(TypeElement el) {
            
            if (el.getKind() == ElementKind.CLASS) {
                if (!el.getSimpleName().toString().startsWith("Abstract")) {
                    processingEnv.getMessager().printMessage(Kind.ERROR, "When using @RAD annotation, class name must begin with 'Abstract'", el);
                    return false;
                }
                if (!el.getModifiers().contains(Modifier.ABSTRACT)) {
                    processingEnv.getMessager().printMessage(Kind.ERROR, "When using @RAD annotation, class must be abstract", el);
                    return false;
                }
                if (!isA(el, "com.codename1.rad.models.Entity", roundEnv)) {
                    processingEnv.getMessager().printMessage(Kind.ERROR, "When using @RAD annotation, class must implement Entity.  "+el.getSimpleName()+" does not.", el);
                    return false;
                }
                if (el.getEnclosingElement().getKind() != ElementKind.PACKAGE) {
                    processingEnv.getMessager().printMessage(Kind.ERROR, "Classes annotated with @RAD cannot be inner classes. ", el);
                    return false;
                }
                if (getPackageElement(el) == null) {
                    processingEnv.getMessager().printMessage(Kind.ERROR, "Classes annoated with @RAD must be in a package.  Cannot be in default package.", el);
                    return false;
                }
            }
            if (el.getKind() == ElementKind.INTERFACE) {
                //if (!el.getSimpleName().toString().startsWith("I")) {
                //    processingEnv.getMessager().printMessage(Kind.ERROR, "When using @RAD annotation, interface must begin with 'I'", el);
                //    return false;
                //}
                if (!isA(el, "com.codename1.rad.models.Entity", roundEnv)) {
                    processingEnv.getMessager().printMessage(Kind.ERROR, "When Using @RAD annotation, interface must extends Entity", el);
                    return false;
                }
                if (el.getEnclosingElement().getKind() != ElementKind.PACKAGE) {
                    processingEnv.getMessager().printMessage(Kind.ERROR, "Interfaces annotated with @RAD cannot be inner classes. ", el);
                    return false;
                }
                if (getPackageElement(el) == null) {
                    processingEnv.getMessager().printMessage(Kind.ERROR, "Interfaces annoated with @RAD must be in a package.  Cannot be in default package.", el);
                    return false;
                }
            }
            return true;
        
        }
        
        synchronized EntityPlan getEntityPlanFor(TypeElement el) {
            try {
                String entityName = getEntityNameFor(el);
                if (el.getEnclosingElement().getKind() != ElementKind.PACKAGE) {
                    
                }
                if (!entityPlans.containsKey(entityName)) {
                    EntityPlan plan = new EntityPlan(getPackageElement(el).getQualifiedName().toString(), entityName);
                    plan.init(roundEnv);
                    entityPlans.put(entityName, plan);
                }
                return entityPlans.get(entityName);
            } catch (IllegalArgumentException ex) {
                return null;
            }
        }
        
    }
    
    private class EntityProperty {
        String name;
        TypeMirror type;
        Element methodElement;
        Set<String> tags = new LinkedHashSet<>();
        
        EntityProperty(String name, TypeMirror type, Element methodElement) {
            this.name = name;
            this.type = type;
            this.methodElement = methodElement;
            if (type == null) {
                processingEnv.getMessager().printMessage(Kind.ERROR, "Property "+name+" has a null type", methodElement);
                throw new IllegalArgumentException("Property "+name+" has a null type");
            }
            
        }
        
        void addTags(String... tags) {
            this.tags.addAll(Arrays.asList(tags));
        }
        
        String getWrapperAccessorCall(RoundEnvironment roundEnv) {
            TypeElement propType = (TypeElement)processingEnv.getTypeUtils().asElement(type);
            TypeMirror propTypeMirror = type;
            
            String typeStr = null;
            switch (propTypeMirror.getKind()) {
                case DOUBLE:
                    typeStr = "Double"; break;
                case INT:
                    typeStr = "Int"; break;
                case FLOAT:
                    typeStr = "Float"; break;
                case BOOLEAN:
                    typeStr = "Boolean"; break;
                case LONG:
                    typeStr = "Long"; break;



            }

            String argsPrefix = "";

            if (typeStr == null && propType.getQualifiedName().contentEquals("com.codename1.rad.models.BaseEntity")) {
                typeStr = "Entity";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("com.codename1.rad.models.EntityList")) {
                typeStr = "EntityList";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.util.Date")) {
                typeStr = "Date";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.String")) {
                typeStr = "Text";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Double")) {
                typeStr = "Double";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Integer")) {
                typeStr = "Integer";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Float")) {
                typeStr = "Float";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Boolean")) {
                typeStr = "Boolean";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Long")) {
                typeStr = "Long";
            }
            if (typeStr == null && isA(propType, "com.codename1.rad.models.EntityList", roundEnv)) {
                typeStr = "EntityList";
                //argsPrefix = propType.getQualifiedName()+".class, ";
            }
            if (typeStr == null && isA(propType, "com.codename1.rad.models.Entity", roundEnv)) {
                typeStr = "Entity";
                //argsPrefix = propType.getQualifiedName()+".class, ";
            }
            

                        
            StringBuilder tagsStrBuilder = new StringBuilder();
            for (String tag : tags) {
                if (tagsStrBuilder.length() > 0) {
                    tagsStrBuilder.append(", ");
                }
                tagsStrBuilder.append(tag);
            }
            String tagsStr = tagsStrBuilder.toString();
            if (typeStr == null) typeStr = "";
            return "get"+typeStr +"("+argsPrefix+tagsStr+")";
        }
        
        String getWrapperSetterCall(RoundEnvironment roundEnv, String valueVarName) {
            TypeElement propType = (TypeElement)processingEnv.getTypeUtils().asElement(type);
            TypeMirror propTypeMirror = type;
            
            String typeStr = null;
            switch (propTypeMirror.getKind()) {
                case DOUBLE:
                    typeStr = "Double"; break;
                case INT:
                    typeStr = "Int"; break;
                case FLOAT:
                    typeStr = "Float"; break;
                case BOOLEAN:
                    typeStr = "Boolean"; break;
                case LONG:
                    typeStr = "Long"; break;



            }

            String argsPrefix = "";

            if (typeStr == null && propType.getQualifiedName().contentEquals("com.codename1.rad.models.Entity")) {
                typeStr = "";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("com.codename1.rad.models.EntityList")) {
                typeStr = "";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.util.Date")) {
                typeStr = "Date";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.String")) {
                typeStr = "Text";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Double")) {
                typeStr = "Double";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Integer")) {
                typeStr = "Integer";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Float")) {
                typeStr = "Float";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Boolean")) {
                typeStr = "Boolean";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Long")) {
                typeStr = "Long";
            }
            if (typeStr == null && isA(propType, "com.codename1.rad.models.EntityList", roundEnv)) {
                typeStr = "";
                //argsPrefix = propType.getQualifiedName()+".class, ";
            }
            if (typeStr == null && isA(propType, "com.codename1.rad.models.Entity", roundEnv)) {
                typeStr = "";
                //argsPrefix = propType.getQualifiedName()+".class, ";
            }
            

                        
            StringBuilder tagsStrBuilder = new StringBuilder();
            for (String tag : tags) {
                if (tagsStrBuilder.length() > 0) {
                    tagsStrBuilder.append(", ");
                }
                tagsStrBuilder.append(tag);
            }
            String tagsStr = tagsStrBuilder.toString();
            if (typeStr == null) typeStr = "";
            return "set"+typeStr +"("+argsPrefix+tagsStr+", "+valueVarName+")";
        }
        
        // Creates the initialization string for the entity type.
        String getTypeString(RoundEnvironment roundEnv) {
            TypeElement propType = (TypeElement)processingEnv.getTypeUtils().asElement(type);
            if (type == null) {
                processingEnv.getMessager().printMessage(Kind.ERROR, "Property "+this.name+" has no type");
                throw new IllegalStateException("Property "+this.name+" has no type");
            }
            TypeMirror propTypeMirror = type;
            
            String typeStr = null;
            switch (propTypeMirror.getKind()) {
                case DOUBLE:
                    typeStr = "Double"; break;
                case INT:
                    typeStr = "Integer"; break;
                case FLOAT:
                    typeStr = "Float"; break;
                case BOOLEAN:
                    typeStr = "Boolean"; break;
                case LONG:
                    typeStr = "Long"; break;



            }

            String argsPrefix = "";

            if (typeStr == null && propType.getQualifiedName().contentEquals("com.codename1.rad.models.Entity")) {
                typeStr = "entity";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("com.codename1.rad.models.EntityList")) {
                typeStr = "entityList";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.util.Date")) {
                typeStr = "date";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.String")) {
                typeStr = "string";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Double")) {
                typeStr = "Double";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Integer")) {
                typeStr = "Integer";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Float")) {
                typeStr = "Float";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Boolean")) {
                typeStr = "Boolean";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Long")) {
                typeStr = "Long";
            }
            if (typeStr == null && isA(propType, "com.codename1.rad.models.EntityList", roundEnv)) {
                typeStr = "list";
                argsPrefix = propType.getQualifiedName()+".class, ";
            }
            if (typeStr == null && isA(propType, "com.codename1.rad.models.Entity", roundEnv)) {
                typeStr = "entity";
                argsPrefix = propType.getQualifiedName()+".class, ";
            }
            if (typeStr == null) {
                typeStr = "object";
                argsPrefix = propType.getQualifiedName()+".class, ";
            }

                        
            StringBuilder tagsStrBuilder = new StringBuilder();
            for (String tag : tags) {
                if (tagsStrBuilder.length() > 0) {
                    tagsStrBuilder.append(", ");
                }
                tagsStrBuilder.append(tag);
            }
            String tagsStr = tagsStrBuilder.toString();

            return typeStr +"("+argsPrefix+"tags(" + tagsStr + "));";
                        
        }

        private String getGetterName() {
            return "get"+name.substring(0, 1).toUpperCase()  + name.substring(1);
        }

        private String getSetterName() {
            return "set"+name.substring(0, 1).toUpperCase()  + name.substring(1);
        }
        
        
                
    }
    
    private class EntityPlan {
        private boolean executed;
        private String packageName;
        private String entityName;
        private List<TypeElement> toProcess = new ArrayList<>();
        private TypeElement entityInterface,
                entityAbstractClass,
                entityImplementationClass,
                entityWrapperClass;
        
        private Map<String,EntityProperty> properties = new HashMap<>();
        
        EntityPlan(String packageName, String name) {
            this.entityName = name;
            this.packageName = packageName;
        }
        
        void init(RoundEnvironment env) {
            Elements elements = processingEnv.getElementUtils();
            entityInterface = elements.getTypeElement(packageName+".I"+entityName);
            if (entityInterface == null || entityInterface.getKind() != ElementKind.INTERFACE) {
                entityInterface = elements.getTypeElement(packageName+"."+entityName);
                if (entityInterface == null || entityInterface.getKind() != ElementKind.INTERFACE) {
                    entityInterface = null;
                }
            }
            entityAbstractClass = elements.getTypeElement(packageName+".Abstract"+entityName);
            entityImplementationClass = elements.getTypeElement(packageName+"."+entityName+"Impl");
            entityWrapperClass = elements.getTypeElement(packageName+"."+entityName+"Wrapper");
            
            initProperties();
            
        }
        
        void initProperties() {
            for (TypeElement el : new TypeElement[]{entityInterface, entityAbstractClass}) {
                if (el != null) {
                    getAllTaggedAndAbstractMethods(null, el).forEach(methodEl -> {
                        String propName = getPropName(methodEl.getSimpleName().toString());
                        if (propName == null) {
                            return;
                        }
                        ExecutableElement eeMethod = (ExecutableElement)methodEl;
                        String methodName = eeMethod.getSimpleName().toString();
                        TypeMirror returnTypeMirror = eeMethod.getReturnType();
                        
                        TypeElement returnType = (TypeElement)processingEnv.getTypeUtils().asElement(returnTypeMirror);
                        TypeMirror paramTypeMirror = null;
                        if (eeMethod.getParameters().size() == 1) {
                            paramTypeMirror = eeMethod.getParameters().get(0).asType();
                        }

                        TypeMirror propTypeMirror = paramTypeMirror == null ? returnTypeMirror : paramTypeMirror;
                        TypeElement propType = (TypeElement)processingEnv.getTypeUtils().asElement(propTypeMirror);
                        
                        EntityProperty prop = getProperty(propName, propTypeMirror, eeMethod);
                        if (prop.type != propTypeMirror) {
                            processingEnv.getMessager().printMessage(Kind.ERROR, "Mismatch property type.  Getter and setter should have same type", eeMethod);
                        }

                        prop.addTags(extractTags(methodEl));
                        if (!validatePropertyTags(prop, methodEl)) {
                            processingEnv.getMessager().printMessage(Kind.ERROR, "Two properties found with the same tags.", el);
                        }

                    });
                }
            }
            
        }
        
        EntityProperty getProperty(String name, TypeMirror type, ExecutableElement methodElement) {
            if (!properties.containsKey(name)) {
                EntityProperty prop = new EntityProperty(name, type, methodElement);
                properties.put(name, prop);
                
            }
            return properties.get(name);
        }
        
        
        
        boolean validatePropertyTags(EntityProperty prop, Element methodEl) {
            HashSet<String> sandbox = new HashSet<String>();
            sandbox.addAll(prop.tags);
            int numTags = sandbox.size();
            for (EntityProperty otherProp : properties.values()) {
                if (otherProp == prop) continue;
                sandbox.removeAll(otherProp.tags);
                if (sandbox.size() != numTags) {
                    // We have two properties with the same tag.
                    processingEnv.getMessager().printMessage(Kind.ERROR, "Two properties with the same tags.", methodEl);
                    return false;
                }
            }
            return true;
        }
        
        
        void executePlan(RoundEnvironment roundEnv) {
            if (executed) return;
            executed = true;
            if (entityInterface != null && toProcess.contains(entityInterface)) {
                // generate the abstract class
                if (entityAbstractClass == null || isAutogenerated(entityAbstractClass)) {
                    generateImplementationClass(roundEnv);
                }
                if (entityWrapperClass == null || isAutogenerated(entityWrapperClass)) {
                    generateWrapperClass(roundEnv);
                }
                
            }
            if (entityAbstractClass != null && toProcess.contains(entityAbstractClass)) {
                if (entityImplementationClass == null || isAutogenerated(entityImplementationClass)) {
                    generateImplementationClass(roundEnv);
                }
                //if (entityInterface == null || isAutogenerated(entityInterface)) {
                //    generateInterface();
                //}
                
            }
        }
        void generateAbstractClass() {
            TypeSpec.Builder entitySpec = TypeSpec.classBuilder("Abstract"+entityName)
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                .addAnnotation(RAD.class)
                .addAnnotation(Autogenerated.class)
                .addSuperinterface(entityInterface.asType())
                .superclass(ClassName.get("com.codename1.rad.models", "Entity"));
            
            JavaFile javaFile = JavaFile.builder(packageName, entitySpec.build())
                .build();
        
            try {
                System.out.println("Generating class "+packageName+".Abstract"+entityName);
                JavaFileObject entityFile = processingEnv.getFiler().createSourceFile(packageName + ".Abstract"+entityName, entityInterface);
                try (PrintWriter writer = new PrintWriter(entityFile.openWriter())) {
                    //javaFile.writeTo(System.out);
                    javaFile.writeTo(writer);
                }


            } catch (IOException ex){}
                 
        }
        
        void generateWrapperClass(RoundEnvironment roundEnv) {
            createEntityWrapper(this, roundEnv);
        }
        
        void generateImplementationClass(RoundEnvironment roundEnv) {
            createEntityClass(this, roundEnv);
        }
        
        void generateInterface() {
            
        }
        
        
    
    }
    
    public boolean processEntities(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        

        ExecutionPlan plan = new ExecutionPlan(annotations, roundEnv);
       
        return true;
    }

    private boolean isEntitySubclass(TypeElement el) {
        DeclaredType superType = (DeclaredType)el.getSuperclass();
        if (superType == null) return false;
        TypeElement superTypeEl = (TypeElement)superType.asElement();

        if (superTypeEl.getQualifiedName().contentEquals(ENTITY_TYPE)) {
            return true;
        }
        return false;

    }
    
    private boolean isA(TypeElement el, String qualifiedName) {
        return isA(el, qualifiedName, null);
    }
    
    private boolean isA(TypeElement el, String qualifiedName, RoundEnvironment roundEnv) {
        if (el == null) return false;
        //System.out.println("isA("+el+"): kind="+el.getKind()+", mirrorKind="+el.asType().getKind());
        TypeMirror mirror = el.asType();
        
        //processingEnv.getElementUtils().getTypeElement(qualifiedName);
        if (processingEnv.getTypeUtils().isAssignable(mirror, processingEnv.getElementUtils().getTypeElement(qualifiedName).asType())) {
            //System.out.println("We have a match "+el+" is assignable to "+qualifiedName);
            return true;
        }
        
        //System.out.println("Checking qualified name "+el.getQualifiedName()+" against "+qualifiedName);
        if (el.getQualifiedName().contentEquals(qualifiedName)) return true;
        
        TypeMirror superClass = el.getSuperclass();
        if (superClass != null) {
            TypeElement superClassTypeEl = (TypeElement)processingEnv.getTypeUtils().asElement(superClass);
            
            if (isA(superClassTypeEl, qualifiedName)) {
                return true;
            }
        }
        for (TypeMirror i : el.getInterfaces()) {
            //System.out.println("Checking interface "+i);
            TypeElement interfaceEl = (TypeElement)processingEnv.getTypeUtils().asElement(i);
           // System.out.println("as element interface is "+interfaceEl);
            if (interfaceEl == null) {
                if (roundEnv != null) {
                    for (Element autogen : roundEnv.getElementsAnnotatedWith(Autogenerated.class)) {
                        if (autogen instanceof TypeElement) {
                            TypeElement autoGenType = (TypeElement)autogen;
                            if (autoGenType.asType().equals(i)) {
                                interfaceEl = autoGenType;
                                break;
                            }
                        }
                    }
                }
            }
            if (isA(interfaceEl, qualifiedName)) {
                return true;
            }
        }
        return false;
        
    }
    
    private List<ExecutableElement> getAllTaggedAndAbstractMethods(List<ExecutableElement> out, TypeElement el) {
        if (out == null) out = new ArrayList<>();
        final List<ExecutableElement> fout = out;
        if (el == null) return out;
        
        el.getEnclosedElements().stream()
                .filter(e -> e.getKind() == ElementKind.METHOD)
                    .filter(e -> e.getAnnotation(RAD.class) != null)
                    .filter(e -> e.getAnnotation(RAD.class).tag().length > 0)
                .forEach(e-> {
                    fout.add((ExecutableElement)e);
                });
        getAllTaggedAndAbstractMethods(out,(TypeElement) processingEnv.getTypeUtils().asElement(el.getSuperclass()));
        for (TypeMirror iface : el.getInterfaces()) {
            getAllTaggedAndAbstractMethods(out, (TypeElement)processingEnv.getTypeUtils().asElement(iface));
        }
        return out;
    }
    
    
    private String[] extractTags(Element e) {
        RAD anno = e.getAnnotation(RAD.class);
        if (anno == null) return new String[0];
        String[] out = e.getAnnotation(RAD.class).tag();
        for (int i=0; i<out.length; i++) {
            validateTag(out[i], e);
            
            
        }
        return out;
    }
    
    private static String getSimpleName(Element e) {
        return e.getSimpleName().toString();
    }
    
    
    private static String[] mergeUnique(String[] s1, String[] s2) {
        List<String> out = new ArrayList<String>(s1.length + s2.length);
        for (String s : s1) {
            if (!out.contains(s)) out.add(s);
        }
        for (String s : s2) {
            if (!out.contains(s)) out.add(s);
        }
        return out.toArray(new String[out.size()]);
    }
    
    private static String getPropName(String methodName) {
        if (methodName.startsWith("get") || methodName.startsWith("set")) {
            return methodName.substring(3, 4).toLowerCase() + methodName.substring(4);
        }
        return null;
    }
    
    
    private boolean isAutogenerated(TypeElement el) {
        return el.getAnnotation(Autogenerated.class) != null;
    }
    
    
    
    private void createEntityClass(EntityPlan entityPlan, RoundEnvironment roundEnv) {
        
        
        
        
        CodeBlock.Builder entityTypeInitializer = CodeBlock.builder();
        List<MethodSpec> methods = new ArrayList<MethodSpec>();
        List<FieldSpec> fields = new ArrayList<FieldSpec>();
        
        
        
        
        entityPlan.properties.values()
                    .forEach(entityProperty -> {
                        
                        CodeBlock.Builder propertyStatement = CodeBlock.builder();
                        
                        
                        propertyStatement.add("RAD_PROPERTY_"+entityProperty.name+"="+entityProperty.getTypeString(roundEnv));
                        entityTypeInitializer.add(propertyStatement.build());
                        MethodSpec methodSpec = MethodSpec.methodBuilder(entityProperty.getGetterName())
                                .returns(ClassName.get(entityProperty.type))
                                .addModifiers(Modifier.PUBLIC)
                                .addCode("return ($T)get(RAD_PROPERTY_"+entityProperty.name+");", entityProperty.type)
                                .build();
                            methods.add(methodSpec);
                        methodSpec = MethodSpec.methodBuilder(entityProperty.getSetterName())
                                
                                .addParameter(ClassName.get(entityProperty.type), "_value")
                                .addModifiers(Modifier.PUBLIC)
                                .addCode("set(RAD_PROPERTY_"+entityProperty.name+", _value);")
                                .build();
                            methods.add(methodSpec);
                       
                        ClassName propertyClass = ClassName.get("com.codename1.rad.models", "Property");
                        FieldSpec.Builder fieldSpec = FieldSpec.builder(
                                propertyClass,
                                "RAD_PROPERTY_"+entityProperty.name, 
                                Modifier.PUBLIC,
                                Modifier.STATIC
                                        
                       );
                       fields.add(fieldSpec.build());
                        
                        
                        
                    });
        
        
        TypeSpec entityType = TypeSpec.anonymousClassBuilder("")
                .superclass(ClassName.get("com.codename1.rad.models", "EntityType"))
                //.addModifiers(Modifier.STATIC, Modifier.PUBLIC, Modifier.FINAL)
                .addInitializerBlock(entityTypeInitializer.build())
                
                .build();
        
        
        
        TypeSpec.Builder entitySpec = TypeSpec.classBuilder(entityPlan.entityName+"Impl")
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addAnnotation(Autogenerated.class)
                //.superclass(entityPlan.entityAbstractClass.asType())
                .addField(
                        FieldSpec.builder(
                                ClassName.get("com.codename1.rad.models", "EntityType"), 
                                "TYPE", Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                                .initializer("$L", entityType)
                                .build()
                        
                        
                )
                .addInitializerBlock(CodeBlock.builder().add("setEntityType(TYPE);").build());
        if (entityPlan.entityAbstractClass != null) {
            entitySpec.superclass(entityPlan.entityAbstractClass.asType());
        } else {
            entitySpec.superclass(ClassName.get("com.codename1.rad.models", "BaseEntity"));
            
        }
        if (entityPlan.entityInterface != null) {
            entitySpec.addSuperinterface(entityPlan.entityInterface.asType());
        }
         
        for (MethodSpec methodSpec : methods) {
            entitySpec.addMethod(methodSpec);
        }
        for (FieldSpec fieldSpec : fields) {
            entitySpec.addField(fieldSpec);
        }
        
        
        // If the class implements any FooSchema interfaces, then out subclass will 
        // implement the corresponding IFoo interface, which itself extends EntityWrapper
        
        
        
        JavaFile javaFile = JavaFile.builder(entityPlan.packageName, entitySpec.build())
                .build();
        
        try {
            JavaFileObject entityFile = processingEnv.getFiler().createSourceFile(entityPlan.packageName+"."+entityPlan.entityName+"Impl", entityPlan.entityAbstractClass, entityPlan.entityInterface);
            try (PrintWriter writer = new PrintWriter(entityFile.openWriter())) {
                //javaFile.writeTo(System.out);
                javaFile.writeTo(writer);
            }
            
            
        } catch (IOException ex){}
        
        
    }
    
    private void createEntityWrapper(EntityPlan entityPlan, RoundEnvironment roundEnv) {
        List<MethodSpec> methods = new ArrayList<MethodSpec>();
        List<FieldSpec> fields = new ArrayList<FieldSpec>();
        
        
        
        
        entityPlan.properties.values()
                    .forEach(entityProperty -> {
                        
                        
                        MethodSpec methodSpec = MethodSpec.methodBuilder(entityProperty.getGetterName())
                                .returns(ClassName.get(entityProperty.type))
                                .addModifiers(Modifier.PUBLIC)
                                .addCode("return ($T)getEntity()."+entityProperty.getWrapperAccessorCall(roundEnv)+";", entityProperty.type)
                                .build();
                            methods.add(methodSpec);
                        methodSpec = MethodSpec.methodBuilder(entityProperty.getSetterName())
                                
                                .addParameter(ClassName.get(entityProperty.type), "_value")
                                .addModifiers(Modifier.PUBLIC)
                                .addCode("getEntity()."+entityProperty.getWrapperSetterCall(roundEnv, "_value")+";")
                                .build();
                            methods.add(methodSpec);
                       
                        
                        
                        
                        
                    });
        
        
        MethodSpec.Builder cnst = MethodSpec.constructorBuilder()
                .addParameter(ClassName.get("com.codename1.rad.models", "Entity"), "entity")
                .addModifiers(Modifier.PUBLIC)
                .addCode("super(entity);");
                
        MethodSpec.Builder wrap = MethodSpec.methodBuilder("wrap")
                .addParameter(ClassName.get("com.codename1.rad.models", "Entity"), "entity")
                .returns(ClassName.get(entityPlan.entityInterface))
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .addCode("if (entity == null) return null;")
                .addCode("if (entity instanceof $T) return ($T)entity;", entityPlan.entityInterface, entityPlan.entityInterface)
                .addCode("$T wrapper = entity.getEntity().getWrapper($T.class);", entityPlan.entityInterface, entityPlan.entityInterface)
                .addCode("if (wrapper != null) return wrapper;")
                .addCode("wrapper = new "+entityPlan.entityName+"Wrapper(entity); entity.getEntity().addWrapper(wrapper);return wrapper;");
                ;
        
        
        
        
        TypeSpec.Builder entitySpec = TypeSpec.classBuilder(entityPlan.entityName+"Wrapper")
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .superclass(ClassName.get("com.codename1.rad.models", "SimpleEntityWrapper"))
                .addMethod(cnst.build())
                .addMethod(wrap.build())
                .addAnnotation(Autogenerated.class);
                //.superclass(entityPlan.entityAbstractClass.asType())
                
                
       
        if (entityPlan.entityInterface != null) {
            entitySpec.addSuperinterface(entityPlan.entityInterface.asType());
        }
         
        for (MethodSpec methodSpec : methods) {
            entitySpec.addMethod(methodSpec);
        }
        for (FieldSpec fieldSpec : fields) {
            entitySpec.addField(fieldSpec);
        }
        
        
        
        
        // If the class implements any FooSchema interfaces, then out subclass will 
        // implement the corresponding IFoo interface, which itself extends EntityWrapper
        
        
        
        JavaFile javaFile = JavaFile.builder(entityPlan.packageName, entitySpec.build())
                .build();
        
        try {
            JavaFileObject entityFile = processingEnv.getFiler().createSourceFile(entityPlan.packageName+"."+entityPlan.entityName+"Wrapper", entityPlan.entityAbstractClass, entityPlan.entityInterface);
            try (PrintWriter writer = new PrintWriter(entityFile.openWriter())) {
                //javaFile.writeTo(System.out);
                javaFile.writeTo(writer);
            }
            
            
        } catch (IOException ex){}
    }
   
}
