package com.codename1.rad.annotations.processors;

import com.codename1.rad.annotations.Autogenerated;
import com.codename1.rad.annotations.RAD;
import com.google.auto.service.AutoService;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.ExecutableType;
import javax.lang.model.type.TypeMirror;
import java.io.File;
import java.lang.annotation.Annotation;
import java.util.Set;

import static com.codename1.rad.annotations.processors.HelperFunctions.getCodenameOneSettingProperties;
import static com.codename1.rad.annotations.processors.HelperFunctions.getPropName;
import static com.codename1.rad.annotations.processors.HelperFunctions.isAutogenerated;
import static com.codename1.rad.annotations.processors.ProcessorConstants.*;
import static com.codename1.rad.annotations.processors.ProcessorConstants.ENTITY_TYPE;
import static com.codename1.rad.annotations.processors.HelperFunctions.getPropName;
import static com.codename1.rad.annotations.processors.HelperFunctions.isAutogenerated;

import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;
import java.io.IOException;
import java.io.PrintWriter;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.MethodSpec;

import java.io.ByteArrayInputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.PackageElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.TypeKind;
import javax.lang.model.util.Elements;
import javax.tools.Diagnostic.Kind;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathFactory;
import org.apache.commons.text.StringEscapeUtils;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

@SupportedAnnotationTypes({RAD_ANNOTATION_TYPE, STUB_ANNOTATION_TYPE, GENERATE_HELPER_ANNOTATION_TYPE})
@SupportedSourceVersion(SourceVersion.RELEASE_8)
@AutoService(Processor.class)
public class EntityProcessor extends BaseProcessor {

    private int roundNum = 1;
    private RoundEnvironment roundEnv;
    private Set<Element> deferred = new HashSet<>();
    private boolean entitiesAddedThisRound;

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(new ProcessingEnvironmentWrapper(processingEnv));
    }

    @Override
    void installTypes(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {

    }

    private class RoundEnvironmentWrapper implements RoundEnvironment {
        final RoundEnvironment wrapped;
        final HashSet<Element> deferred;

        RoundEnvironmentWrapper(RoundEnvironment wrapped, Set<Element> deferred) {
            this.wrapped = wrapped;
            this.deferred = new HashSet<>();
            this.deferred.addAll(deferred);
        }

        @Override
        public boolean processingOver() {
            return wrapped.processingOver();
        }

        @Override
        public boolean errorRaised() {
            return wrapped.errorRaised();
        }

        @Override
        public Set<? extends Element> getRootElements() {
            HashSet<Element> out = new HashSet<>();
            out.addAll(wrapped.getRootElements());
            return out;
        }

        @Override
        public Set<? extends Element> getElementsAnnotatedWith(TypeElement a) {
            HashSet<Element> out = new HashSet<>();
            out.addAll(wrapped.getElementsAnnotatedWith(a));
            return out;
        }

        @Override
        public Set<? extends Element> getElementsAnnotatedWith(Class<? extends Annotation> a) {
            HashSet<Element> out = new HashSet<>();
            out.addAll(wrapped.getElementsAnnotatedWith(a));
            out.addAll(deferred.stream().filter(e->e.getAnnotation(a) != null).collect(Collectors.toList()));
            return out;
        }
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        if (roundNum == 1) {
            // In the first round we will delete stale .xsd files so that the annotation
            // processor will be forced to generate new ones.
            try {
                File commonDirectory = getCodenameOneSettingProperties().getParentFile();
                File javaSources = new File(commonDirectory, "src" + File.separator + "main" + File.separator + "java");
                File radViewSources = new File(commonDirectory, "src" + File.separator + "main" + File.separator + "rad" + File.separator + "views");
                if (javaSources.exists() && radViewSources.exists()) {
                    new StaleXMLSchemaGarbageCollector(javaSources, radViewSources).run();
                }
            } catch (Exception ex) {
                processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, "Unable to delete stale XSD files: "+ex.getMessage());
            }

        }

        env().nextRound();
        long startTime = System.currentTimeMillis();
        this.entitiesAddedThisRound = false;
        this.roundEnv = roundEnv;

        installTypes(annotations, roundEnv);
        boolean out = processSchemas(annotations, roundEnv);
        out = processEntities(annotations, roundEnv) || out;
        if (entitiesAddedThisRound) {

            deferred.addAll(new ViewProcessor(processingEnv).defer(annotations, roundEnv));

        } else {

            ViewProcessor vp = new ViewProcessor(processingEnv);
            vp.installTypes(annotations, new RoundEnvironmentWrapper(roundEnv, deferred));
            out = vp.process(annotations, new RoundEnvironmentWrapper(roundEnv, deferred)) || out;
            deferred.clear();
        }
        
        startTime = System.currentTimeMillis() - startTime;
        if (startTime > 10) {
            System.out.println("CodeRAD Annotation Processor round "+roundNum+" took " + startTime + " milliseconds.");
        }
        roundNum++;
        return out;
    }

    private class ExecutionPlan {
        private Map<String,EntityPlan> entityPlans = new HashMap<>();
        private RoundEnvironment roundEnv;
        private Set<? extends TypeElement> annotations;
        
        ExecutionPlan(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
            this.annotations = annotations;
            this.roundEnv = roundEnv;
            
            Set<? extends Element> annotatedElements = (Set<? extends TypeElement>)roundEnv.getElementsAnnotatedWith(RAD.class);

            Set<EntityPlan> plans = new LinkedHashSet<>();
            TypeElement entityView = processingEnv.getElementUtils().getTypeElement("com.codename1.rad.ui.EntityView");
            TypeElement componentBuilder = processingEnv.getElementUtils().getTypeElement("com.codename1.rad.ui.ComponentBuilder");
            TypeElement component = processingEnv.getElementUtils().getTypeElement("com.codename1.ui.Component");
            for (Element e : annotatedElements) {
                if (e instanceof TypeElement) {
                    TypeElement typeEl = (TypeElement)e;

                    if (isA(typeEl, "com.codename1.rad.ui.EntityView")) {
                        // If this is an EntityView, then we will process this using the EntityView pathway
                        // Which will try to generate an EntityView from a template.
                        continue;
                    }

                    if (isA(typeEl, "com.codename1.rad.ui.ComponentBuilder")) {
                        // If this is an EntityView, then we will process this using the EntityView pathway
                        // Which will try to generate an EntityView from a template.
                        continue;
                    }

                    if (!validate(typeEl)) {
                        return;
                    }
                    EntityPlan plan = getEntityPlanFor(typeEl);
                    
                    if (plan == null) {
                        throw new RuntimeException("Problem processing @RAD annotation.  Failed to get plan for element");
                        
                    }
                    plan.toProcess.add(typeEl);
                    plans.add(plan);
                }
            }
            for (EntityPlan plan : plans) {
                plan.executePlan(roundEnv);
            }
        }
        
        boolean validate(TypeElement el) {
            
            if (el.getKind() == ElementKind.CLASS) {
                if (!el.getSimpleName().toString().startsWith("Abstract")) {
                    processingEnv.getMessager().printMessage(Kind.ERROR, "When using @RAD annotation, class name must begin with 'Abstract'", el);
                    return false;
                }
                if (!el.getModifiers().contains(Modifier.ABSTRACT)) {
                    processingEnv.getMessager().printMessage(Kind.ERROR, "When using @RAD annotation, class must be abstract", el);
                    return false;
                }
                if (!isA(el, "com.codename1.rad.models.Entity")) {
                    processingEnv.getMessager().printMessage(Kind.ERROR, "When using @RAD annotation, class must implement Entity.  "+el.getSimpleName()+" does not.", el);
                    return false;
                }
                if (el.getEnclosingElement().getKind() != ElementKind.PACKAGE) {
                    processingEnv.getMessager().printMessage(Kind.ERROR, "Classes annotated with @RAD cannot be inner classes. ", el);
                    return false;
                }
                if (getPackageElement(el) == null) {
                    processingEnv.getMessager().printMessage(Kind.ERROR, "Classes annoated with @RAD must be in a package.  Cannot be in default package.", el);
                    return false;
                }
            }
            if (el.getKind() == ElementKind.INTERFACE) {
                if (!isA(el, "com.codename1.rad.models.Entity")) {
                    processingEnv.getMessager().printMessage(Kind.ERROR, "When Using @RAD annotation, interface must extends Entity", el);
                    return false;
                }
                if (el.getEnclosingElement().getKind() != ElementKind.PACKAGE) {
                    processingEnv.getMessager().printMessage(Kind.ERROR, "Interfaces annotated with @RAD cannot be inner classes. ", el);
                    return false;
                }
                if (getPackageElement(el) == null) {
                    processingEnv.getMessager().printMessage(Kind.ERROR, "Interfaces annoated with @RAD must be in a package.  Cannot be in default package.", el);
                    return false;
                }
            }
            return true;
        
        }
        
        synchronized EntityPlan getEntityPlanFor(TypeElement el) {
            try {
                String entityName = getEntityNameFor(el);
                if (el.getEnclosingElement().getKind() != ElementKind.PACKAGE) {
                    
                }
                if (!entityPlans.containsKey(entityName)) {
                    EntityPlan plan = new EntityPlan(getPackageElement(el).getQualifiedName().toString(), entityName);
                    plan.init(roundEnv);
                    entityPlans.put(entityName, plan);
                }
                return entityPlans.get(entityName);
            } catch (IllegalArgumentException ex) {
                return null;
            }
        }
    }
    
    private class EntityProperty {
        String name;
        TypeMirror type;
        Element methodElement;
        Set<String> tags = new LinkedHashSet<>();
        String initialValue = null;
        
        EntityProperty(String name, TypeMirror type, Element methodElement) {
            this.name = name;
            this.type = type;
            this.methodElement = methodElement;
            if (type == null) {
                processingEnv.getMessager().printMessage(Kind.ERROR, "Property "+name+" has a null type", methodElement);
                throw new IllegalArgumentException("Property "+name+" has a null type");
            }
        }

        void setInitialValue(String value) {
            this.initialValue = value;
        }

        void addTags(String... tags) {
            this.tags.addAll(Arrays.asList(tags));
        }
        
        String getWrapperAccessorCall(RoundEnvironment roundEnv) {
            TypeElement propType = (TypeElement)processingEnv.getTypeUtils().asElement(type);
            TypeMirror propTypeMirror = type;
            
            String typeStr = null;
            switch (propTypeMirror.getKind()) {
                case DOUBLE:
                    typeStr = "Double"; break;
                case INT:
                    typeStr = "Int"; break;
                case FLOAT:
                    typeStr = "Float"; break;
                case BOOLEAN:
                    typeStr = "Boolean"; break;
                case LONG:
                    typeStr = "Long"; break;
            }

            String argsPrefix = "";

            if (typeStr == null && propType.getQualifiedName().contentEquals("com.codename1.rad.models.BaseEntity")) {
                typeStr = "Entity";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("com.codename1.rad.models.EntityList")) {
                typeStr = "EntityList";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.util.Date")) {
                typeStr = "Date";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.String")) {
                typeStr = "Text";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Double")) {
                typeStr = "Double";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Integer")) {
                typeStr = "Int";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Float")) {
                typeStr = "Float";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Boolean")) {
                typeStr = "Boolean";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Long")) {
                typeStr = "Long";
            }
            if (typeStr == null && isA(propType, "com.codename1.rad.models.EntityList")) {
                typeStr = "EntityList";
            }
            if (typeStr == null && isA(propType, "com.codename1.rad.models.Entity")) {
                typeStr = "Entity";
            }

            StringBuilder tagsStrBuilder = new StringBuilder();
            for (String tag : tags) {
                if (tagsStrBuilder.length() > 0) {
                    tagsStrBuilder.append(", ");
                }
                tagsStrBuilder.append(tag);
            }
            String tagsStr = tagsStrBuilder.toString();
            if (typeStr == null) typeStr = "";
            return "get"+typeStr +"("+argsPrefix+tagsStr+")";
        }
        
        String getWrapperSetterCall(RoundEnvironment roundEnv, String valueVarName) {
            TypeElement propType = (TypeElement)processingEnv.getTypeUtils().asElement(type);
            TypeMirror propTypeMirror = type;
            
            String typeStr = null;
            switch (propTypeMirror.getKind()) {
                case DOUBLE:
                    typeStr = "Double"; break;
                case INT:
                    typeStr = "Int"; break;
                case FLOAT:
                    typeStr = "Float"; break;
                case BOOLEAN:
                    typeStr = "Boolean"; break;
                case LONG:
                    typeStr = "Long"; break;
            }

            String argsPrefix = "";

            if (typeStr == null && propType.getQualifiedName().contentEquals("com.codename1.rad.models.Entity")) {
                typeStr = "";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("com.codename1.rad.models.EntityList")) {
                typeStr = "";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.util.Date")) {
                typeStr = "Date";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.String")) {
                typeStr = "Text";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Double")) {
                typeStr = "Double";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Integer")) {
                typeStr = "Int";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Float")) {
                typeStr = "Float";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Boolean")) {
                typeStr = "Boolean";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Long")) {
                typeStr = "Long";
            }
            if (typeStr == null && isA(propType, "com.codename1.rad.models.EntityList")) {
                typeStr = "";
                //argsPrefix = propType.getQualifiedName()+".class, ";
            }
            if (typeStr == null && isA(propType, "com.codename1.rad.models.Entity")) {
                typeStr = "";
                //argsPrefix = propType.getQualifiedName()+".class, ";
            }

            StringBuilder tagsStrBuilder = new StringBuilder();
            for (String tag : tags) {
                if (tagsStrBuilder.length() > 0) {
                    tagsStrBuilder.append(", ");
                }
                tagsStrBuilder.append(tag);
            }
            String tagsStr = tagsStrBuilder.toString();
            if (typeStr == null) typeStr = "";
            return "set"+typeStr +"("+argsPrefix+tagsStr+", "+valueVarName+")";
        }
        
        // Creates the initialization string for the entity type.
        String getTypeString(RoundEnvironment roundEnv) {
            TypeElement propType = (TypeElement)processingEnv.getTypeUtils().asElement(type);
            if (type == null) {
                processingEnv.getMessager().printMessage(Kind.ERROR, "Property "+this.name+" has no type");
                throw new IllegalStateException("Property "+this.name+" has no type");
            }
            TypeMirror propTypeMirror = type;
            
            String typeStr = null;
            switch (propTypeMirror.getKind()) {
                case DOUBLE:
                    typeStr = "Double"; break;
                case INT:
                    typeStr = "Integer"; break;
                case FLOAT:
                    typeStr = "Float"; break;
                case BOOLEAN:
                    typeStr = "Boolean"; break;
                case LONG:
                    typeStr = "Long"; break;
            }

            String argsPrefix = "";

            if (typeStr == null && propType.getQualifiedName().contentEquals("com.codename1.rad.models.Entity")) {
                typeStr = "entity";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("com.codename1.rad.models.EntityList")) {
                typeStr = "entityList";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.util.Date")) {
                typeStr = "date";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.String")) {
                typeStr = "string";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Double")) {
                typeStr = "Double";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Integer")) {
                typeStr = "Integer";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Float")) {
                typeStr = "Float";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Boolean")) {
                typeStr = "Boolean";
            }
            if (typeStr == null && propType.getQualifiedName().contentEquals("java.lang.Long")) {
                typeStr = "Long";
            }
            if (typeStr == null && isA(propType, "com.codename1.rad.models.EntityList")) {
                typeStr = "list";
                argsPrefix = propType.getQualifiedName()+".class, ";
            }
            if (typeStr == null && isA(propType, "com.codename1.rad.models.Entity")) {
                typeStr = "entity";
                argsPrefix = propType.getQualifiedName()+".class, ";
            }
            if (typeStr == null) {
                typeStr = "object";
                argsPrefix = propType.getQualifiedName()+".class, ";
            }
                        
            StringBuilder tagsStrBuilder = new StringBuilder();
            for (String tag : tags) {
                if (tagsStrBuilder.length() > 0) {
                    tagsStrBuilder.append(", ");
                }
                tagsStrBuilder.append(tag);
            }
            String tagsStr = tagsStrBuilder.toString();

            return typeStr +"("+argsPrefix+"tags(" + tagsStr + "));";
        }

        private String getGetterName() {
            String prefix = "get";
            if (type.getKind() == TypeKind.BOOLEAN || (type.toString().equals("java.lang.Boolean"))) {
                prefix = "is";
            }
            return prefix+name.substring(0, 1).toUpperCase()  + name.substring(1);
        }

        private String getSetterName() {
            return "set"+name.substring(0, 1).toUpperCase()  + name.substring(1);
        }
    }
    
    private class EntityPlan {
        private boolean executed;
        private String packageName;
        private String entityName;
        private List<TypeElement> toProcess = new ArrayList<>();
        private TypeElement entityInterface,
                entityAbstractClass,
                entityImplementationClass,
                entityWrapperClass;
        
        private Map<String,EntityProperty> properties = new HashMap<>();
        
        EntityPlan(String packageName, String name) {
            this.entityName = name;
            this.packageName = packageName;
        }
        
        void init(RoundEnvironment env) {
            Elements elements = processingEnv.getElementUtils();
            entityInterface = elements.getTypeElement(packageName+".I"+entityName);
            if (entityInterface == null || entityInterface.getKind() != ElementKind.INTERFACE) {
                entityInterface = elements.getTypeElement(packageName+"."+entityName);
                if (entityInterface == null || entityInterface.getKind() != ElementKind.INTERFACE) {
                    entityInterface = null;
                }
            }
            entityAbstractClass = elements.getTypeElement(packageName+".Abstract"+entityName);
            entityImplementationClass = elements.getTypeElement(packageName+"."+entityName+"Impl");
            entityWrapperClass = elements.getTypeElement(packageName+"."+entityName+"Wrapper");
            initProperties();
        }
        
        void initProperties() {
            for (TypeElement el : new TypeElement[]{entityInterface, entityAbstractClass}) {
                if (el != null) {
                    getAllTaggedAndAbstractMethods(null, el).forEach(methodEl -> {
                        String propName = getPropName(methodEl.getSimpleName().toString());
                        if (propName == null) {
                            return;
                        }
                        if (methodEl.getSimpleName().toString().startsWith("is") && (!"boolean".equalsIgnoreCase(methodEl.getReturnType().toString()) && !"java.lang.Boolean".equalsIgnoreCase(methodEl.getReturnType().toString()))) {
                            return;
                        }
                        ExecutableElement eeMethod = (ExecutableElement)methodEl;
                        String methodName = eeMethod.getSimpleName().toString();
                        TypeMirror returnTypeMirror = eeMethod.getReturnType();
                        
                        TypeElement returnType = (TypeElement)processingEnv.getTypeUtils().asElement(returnTypeMirror);
                        TypeMirror paramTypeMirror = null;
                        if (eeMethod.getParameters().size() == 1) {
                            paramTypeMirror = eeMethod.getParameters().get(0).asType();
                        }

                        TypeMirror propTypeMirror = paramTypeMirror == null ? returnTypeMirror : paramTypeMirror;
                        TypeElement propType = (TypeElement)processingEnv.getTypeUtils().asElement(propTypeMirror);
                        
                        EntityProperty prop = getProperty(propName, propTypeMirror, eeMethod);
                        if (prop.type != propTypeMirror) {
                            processingEnv.getMessager().printMessage(Kind.ERROR, "Mismatch property type.  Getter and setter should have same type", eeMethod);
                        }

                        prop.addTags(extractTags(methodEl));
                        if (!validatePropertyTags(prop, methodEl)) {
                            processingEnv.getMessager().printMessage(Kind.ERROR, "Two properties found with the same tags.", el);
                        }

                        RAD radAnno = methodEl.getAnnotation(RAD.class);
                        if (radAnno != null) {
                            String initialValue = radAnno.initialValue();
                            if (initialValue != null && !initialValue.isEmpty()) {
                                prop.setInitialValue(initialValue);
                            }
                        }
                    });
                }
            }
            
        }
        
        EntityProperty getProperty(String name, TypeMirror type, ExecutableElement methodElement) {
            if (!properties.containsKey(name)) {
                EntityProperty prop = new EntityProperty(name, type, methodElement);
                properties.put(name, prop);
            }
            return properties.get(name);
        }

        boolean validatePropertyTags(EntityProperty prop, Element methodEl) {
            HashSet<String> sandbox = new HashSet<String>();
            sandbox.addAll(prop.tags);
            int numTags = sandbox.size();
            if (numTags == 0) return true;
            for (EntityProperty otherProp : properties.values()) {
                if (otherProp == prop) continue;
                sandbox.removeAll(otherProp.tags);
                if (sandbox.size() != numTags) {
                    // We have two properties with the same tag.
                    processingEnv.getMessager().printMessage(Kind.ERROR, "Two properties with the same tags.", methodEl);
                    return false;
                }
            }
            return true;
        }

        void executePlan(RoundEnvironment roundEnv) {
            if (executed) return;
            executed = true;
            if (entityInterface != null && toProcess.contains(entityInterface)) {
                // generate the abstract class
                if (entityAbstractClass == null || isAutogenerated(entityAbstractClass)) {
                    generateImplementationClass(roundEnv);
                }
                if (entityWrapperClass == null || isAutogenerated(entityWrapperClass)) {
                    generateWrapperClass(roundEnv);
                }
            }
            if (entityAbstractClass != null && toProcess.contains(entityAbstractClass)) {
                if (entityImplementationClass == null || isAutogenerated(entityImplementationClass)) {
                    generateImplementationClass(roundEnv);
                }
            }
        }
        void generateAbstractClass() {
            TypeSpec.Builder entitySpec = TypeSpec.classBuilder("Abstract"+entityName)
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                .addAnnotation(RAD.class)
                .addAnnotation(Autogenerated.class)
                .addSuperinterface(entityInterface.asType())
                .superclass(ClassName.get("com.codename1.rad.models", "Entity"));
            
            JavaFile javaFile = JavaFile.builder(packageName, entitySpec.build())
                .build();
        
            try {
                JavaFileObject entityFile = processingEnv.getFiler().createSourceFile(packageName + ".Abstract"+entityName, entityInterface);
                try (PrintWriter writer = new PrintWriter(entityFile.openWriter())) {
                    //javaFile.writeTo(System.out);
                    entitiesAddedThisRound = true;
                    javaFile.writeTo(writer);
                }
            } catch (IOException ex){}
        }
        
        void generateWrapperClass(RoundEnvironment roundEnv) {
            createEntityWrapper(this, roundEnv);
        }
        
        void generateImplementationClass(RoundEnvironment roundEnv) {
            createEntityClass(this, roundEnv);
        }
        
        void generateInterface() {
            
        }
    }
    
    public boolean processEntities(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        ExecutionPlan plan = new ExecutionPlan(annotations, roundEnv);
        return true;
    }

    private void createEntityClass(EntityPlan entityPlan, RoundEnvironment roundEnv) {
        CodeBlock.Builder entityTypeInitializer = CodeBlock.builder();
        CodeBlock.Builder initializer = CodeBlock.builder();
        List<MethodSpec> methods = new ArrayList<MethodSpec>();
        List<FieldSpec> fields = new ArrayList<FieldSpec>();
        initializer.add("setEntityType(TYPE);\n");
        
        entityPlan.properties.values()
                    .forEach(entityProperty -> {
                        CodeBlock.Builder propertyStatement = CodeBlock.builder();
                        propertyStatement.add("RAD_PROPERTY_"+entityProperty.name+"="+entityProperty.getTypeString(roundEnv));
                        entityTypeInitializer.add(propertyStatement.build());
                        MethodSpec.Builder methodSpecB = MethodSpec.methodBuilder(entityProperty.getGetterName())
                                .returns(ClassName.get(entityProperty.type))
                                .addModifiers(Modifier.PUBLIC);

                        if (entityProperty.type.getKind() == TypeKind.BOOLEAN) {
                            methodSpecB.addCode("Boolean out = getBoolean(RAD_PROPERTY_" + entityProperty.name + "); \n" +
                                    "return out == null ? false : out;");
                        } else if (entityProperty.type.getKind() == TypeKind.INT) {
                            methodSpecB.addCode("Integer out = getInt(RAD_PROPERTY_" + entityProperty.name + ");\n" +
                                    "return out == null ? 0 : out;");
                        } else if (entityProperty.type.getKind() == TypeKind.FLOAT) {
                            methodSpecB.addCode("Float out = getFloat(RAD_PROPERTY_" + entityProperty.name + ");\n" +
                                    "return out == null ? 0f : out;");

                        } else if (entityProperty.type.getKind() == TypeKind.DOUBLE) {
                            methodSpecB.addCode("Double out = getDouble(RAD_PROPERTY_" + entityProperty.name + ");\n" +
                                    "return out == null ? 0 : out;");
                        } else if (entityProperty.type.getKind() == TypeKind.LONG) {
                            methodSpecB.addCode("Long out = getLong(RAD_PROPERTY_" + entityProperty.name + ");\n" +
                                    "return out == null ? 0L : out;");
                        } else if (entityProperty.type.getKind() == TypeKind.DECLARED && entityProperty.type.toString().equals("java.util.Date")) {
                            methodSpecB.addCode("return getDate(RAD_PROPERTY_" + entityProperty.name + ");");
                        } else if (entityProperty.type.getKind() == TypeKind.DECLARED && entityProperty.type.toString().equals("java.lang.String")) {
                            methodSpecB.addCode("return getText(RAD_PROPERTY_" + entityProperty.name + ");");
                        } else {
                            methodSpecB.addCode("return ($T)get(RAD_PROPERTY_" + entityProperty.name + ");", entityProperty.type);
                        }

                        MethodSpec methodSpec = methodSpecB.build();

                            methods.add(methodSpec);
                        methodSpec = MethodSpec.methodBuilder(entityProperty.getSetterName())
                                
                                .addParameter(ClassName.get(entityProperty.type), "_value")
                                .addModifiers(Modifier.PUBLIC)
                                .addCode("set(RAD_PROPERTY_"+entityProperty.name+", _value);")
                                .build();
                            methods.add(methodSpec);
                       
                        ClassName propertyClass = ClassName.get("com.codename1.rad.models", "Property");
                        FieldSpec.Builder fieldSpec = FieldSpec.builder(
                                propertyClass,
                                "RAD_PROPERTY_"+entityProperty.name, 
                                Modifier.PUBLIC,
                                Modifier.STATIC
                                        
                       );

                        if (entityProperty.initialValue != null) {
                            if ("new".equals(entityProperty.initialValue)) {
                                TypeKind propKind = entityProperty.type.getKind();
                                String value = null;
                                if (propKind == TypeKind.INT || propKind == TypeKind.FLOAT || propKind == TypeKind.DOUBLE || propKind == TypeKind.LONG || propKind == TypeKind.BYTE || propKind == TypeKind.SHORT) {
                                    value = "0";
                                } else if (propKind == TypeKind.DECLARED) {
                                    TypeElement typeEl = (TypeElement)((DeclaredType)entityProperty.type).asElement();
                                    if (typeEl != null) {
                                        if (typeEl.getKind() == ElementKind.INTERFACE) {
                                            if (isA(typeEl, "com.codename1.rad.models.Entity")) {
                                                String implName = typeEl.getQualifiedName() + "Impl";
                                                value = "new " + implName + "()";
                                            } else if (typeEl.getQualifiedName().contentEquals("java.util.List") || typeEl.getQualifiedName().contentEquals("java.util.Collection")) {
                                                value = "new java.util.ArrayList()";
                                            } else if (typeEl.getQualifiedName().contentEquals("java.util.Set")) {
                                                value = "new java.util.HashSet()";
                                            } else {
                                                processingEnv.getMessager().printMessage(Kind.ERROR, "Cannot find class to create new inital value for property "+entityProperty.name, entityProperty.methodElement);
                                            }
                                        } else {
                                            value = "new "+typeEl.getQualifiedName()+"()";
                                        }
                                    }
                                }
                                if (value == null) {
                                    processingEnv.getMessager().printMessage(Kind.ERROR, "Failed to find appropriate constructor for initialValue of property "+entityProperty.name+" of entity "+entityPlan.entityName, entityProperty.methodElement);
                                } else {
                                    initializer.add(entityProperty.getSetterName() + "(" + value + ");\n");
                                }
                            } else {
                                initializer.add(entityProperty.getSetterName() + "(" + entityProperty.initialValue + ");\n");
                            }
                        }

                       fields.add(fieldSpec.build());
                    });

        entityTypeInitializer.addStatement("register("+entityPlan.entityName+"Impl.class, this);");
        entityTypeInitializer.addStatement("register("+entityPlan.entityName+".class, this, type -> {return new " + entityPlan.entityName+"Impl();});");
        
        TypeSpec entityType = TypeSpec.anonymousClassBuilder("")

                .superclass(ClassName.get("com.codename1.rad.models", "EntityType"))
                //.addModifiers(Modifier.STATIC, Modifier.PUBLIC, Modifier.FINAL)
                .addInitializerBlock(entityTypeInitializer.build())
                
                .build();

        TypeSpec.Builder entitySpec = TypeSpec.classBuilder(entityPlan.entityName+"Impl")
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addAnnotation(Autogenerated.class)
                //.superclass(entityPlan.entityAbstractClass.asType())
                .addField(
                        FieldSpec.builder(
                                ClassName.get("com.codename1.rad.models", "EntityType"), 
                                "TYPE", Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                                .initializer("$L", entityType)
                                .build()
                )
                .addInitializerBlock(initializer.build());
        if (entityPlan.entityAbstractClass != null) {
            entitySpec.superclass(entityPlan.entityAbstractClass.asType());
        } else {
            entitySpec.superclass(ClassName.get("com.codename1.rad.models", "BaseEntity"));
        }
        if (entityPlan.entityInterface != null) {
            entitySpec.addSuperinterface(entityPlan.entityInterface.asType());
        }

        for (MethodSpec methodSpec : methods) {
            entitySpec.addMethod(methodSpec);
        }
        for (FieldSpec fieldSpec : fields) {
            entitySpec.addField(fieldSpec);
        }

        // If the class implements any FooSchema interfaces, then out subclass will 
        // implement the corresponding IFoo interface, which itself extends EntityWrapper

        JavaFile javaFile = JavaFile.builder(entityPlan.packageName, entitySpec.build())
                .build();
        
        try {
            JavaFileObject entityFile = processingEnv.getFiler().createSourceFile(entityPlan.packageName+"."+entityPlan.entityName+"Impl", entityPlan.entityAbstractClass, entityPlan.entityInterface);
            try (PrintWriter writer = new PrintWriter(entityFile.openWriter())) {
                //javaFile.writeTo(System.out);
                entitiesAddedThisRound = true;
                javaFile.writeTo(writer);
            }
        } catch (IOException ex){}
    }

    private void createEntityWrapper(EntityPlan entityPlan, RoundEnvironment roundEnv) {
        List<MethodSpec> methods = new ArrayList<MethodSpec>();
        List<FieldSpec> fields = new ArrayList<FieldSpec>();
        
        
        
        
        entityPlan.properties.values()
                    .forEach(entityProperty -> {
                        MethodSpec methodSpec = MethodSpec.methodBuilder(entityProperty.getGetterName())
                                .returns(ClassName.get(entityProperty.type))
                                .addModifiers(Modifier.PUBLIC)
                                .addCode("return ($T)getEntity()."+entityProperty.getWrapperAccessorCall(roundEnv)+";", entityProperty.type)
                                .build();
                            methods.add(methodSpec);

                        methodSpec = MethodSpec.methodBuilder(entityProperty.getSetterName())
                                
                                .addParameter(ClassName.get(entityProperty.type), "_value")
                                .addModifiers(Modifier.PUBLIC)
                                .addCode("getEntity()."+entityProperty.getWrapperSetterCall(roundEnv, "_value")+";")
                                .build();
                            methods.add(methodSpec);

                    });

        MethodSpec.Builder cnst = MethodSpec.constructorBuilder()
                .addParameter(ClassName.get("com.codename1.rad.models", "Entity"), "entity")
                .addModifiers(Modifier.PUBLIC)
                .addCode("super(entity);");
                
        MethodSpec.Builder wrap = MethodSpec.methodBuilder("wrap")
                .addParameter(ClassName.get("com.codename1.rad.models", "Entity"), "entity")
                .returns(ClassName.get(entityPlan.entityInterface))
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .addCode("if (entity == null) return null;")
                .addCode("if (entity instanceof $T) return ($T)entity;", entityPlan.entityInterface, entityPlan.entityInterface)
                .addCode("$T wrapper = entity.getEntity().getWrapper($T.class);", entityPlan.entityInterface, entityPlan.entityInterface)
                .addCode("if (wrapper != null) return wrapper;")
                .addCode("wrapper = new "+entityPlan.entityName+"Wrapper(entity); entity.getEntity().addWrapper(wrapper);return wrapper;");
                ;

        TypeSpec.Builder entitySpec = TypeSpec.classBuilder(entityPlan.entityName+"Wrapper")
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .superclass(ClassName.get("com.codename1.rad.models", "SimpleEntityWrapper"))
                .addMethod(cnst.build())
                .addMethod(wrap.build())
                .addAnnotation(Autogenerated.class);
                //.superclass(entityPlan.entityAbstractClass.asType())
                
                
       
        if (entityPlan.entityInterface != null) {
            entitySpec.addSuperinterface(entityPlan.entityInterface.asType());
        }
         
        for (MethodSpec methodSpec : methods) {
            entitySpec.addMethod(methodSpec);
        }
        for (FieldSpec fieldSpec : fields) {
            entitySpec.addField(fieldSpec);
        }

        // If the class implements any FooSchema interfaces, then out subclass will 
        // implement the corresponding IFoo interface, which itself extends EntityWrapper
        
        
        
        JavaFile javaFile = JavaFile.builder(entityPlan.packageName, entitySpec.build())
                .build();
        
        try {
            JavaFileObject entityFile = processingEnv.getFiler().createSourceFile(entityPlan.packageName+"."+entityPlan.entityName+"Wrapper", entityPlan.entityAbstractClass, entityPlan.entityInterface);
            try (PrintWriter writer = new PrintWriter(entityFile.openWriter())) {
                //javaFile.writeTo(System.out);
                entitiesAddedThisRound = true;
                javaFile.writeTo(writer);
            }

        } catch (IOException ex){}
    }
   
}
